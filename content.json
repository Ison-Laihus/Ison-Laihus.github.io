[{"title":"Linux 下安装libmysqlclient-dev找不到链接库","slug":"Linux-下安装libmysqlclient-dev找不到链接库","date":"2018-03-26T10:19:59.000Z","updated":"2018-03-26T14:04:57.704Z","comments":true,"path":"2018/03/26/Linux-下安装libmysqlclient-dev找不到链接库/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/26/Linux-下安装libmysqlclient-dev找不到链接库/","excerpt":"","text":"前言想用C++在Linux环境下操作MySQL数据库。 环境Ubuntu16.04MySQL5.7gcc 5.4.0 环境搭建安装mysql sudo apt-get install mysql-server mysql-client 安装libmysqlclient-dev sudo apt-get install libmysqlclient-dev libmysqlclient-dev这个库中有着操作mysql数据库的一些头文件和链接库 问题在 /usr/include 中可以找到mysql文件夹，其中有一些操作mysql的头文件但是在 /usr/lib 中找不到链接库 libmysqlclient.so 原因在安装 libmysqlclient-dev 的时候，将 libmysqlclient.so 链接库文件放置在了 /usr/lib/x86_64-linux-gnu 这个文件夹中。 解决办法在 /usr/lib 中增加 libmysqlclient.so 的链接： ln -s /usr/lib/x86_64-linux-gnu/libmysqlclient.so /usr/lib/libmysqlclient.so 这样一来，问题就解决了","categories":[],"tags":[{"name":"Linux MySQL C++","slug":"Linux-MySQL-C","permalink":"http://Ison-Laihus.github.io/tags/Linux-MySQL-C/"}]},{"title":"Linux 下建立链接","slug":"Linux-下建立链接","date":"2018-03-26T09:54:56.000Z","updated":"2018-03-26T10:19:01.798Z","comments":true,"path":"2018/03/26/Linux-下建立链接/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/26/Linux-下建立链接/","excerpt":"","text":"链接，在Linux文件系统中，可以视其为档案的别名。 链接的分类 硬链接 以文件的副本的形式存在，但不占用实际空间 不允许给目录创建硬链接 只有在同一个文件系统中才能创建 软链接 以路径的形式存在，类似于Windows操作系统中的快捷方式 可以跨文件系统 可以对一个不存在的文件名进行链接 可以对目录进行链接 创建链接的命令命令格式 ln [参数] [源文件或目录] [目标文件或目录] 命令参数必要参数 -b 删除，覆盖以前建立的链接 -d 允许超级用户制作目录的硬链接 -f 强制执行 -i 交互模式，文件存在则提示用户是否覆盖 -n 把符号链接视为一般目录 -s 软链接（符号链接） -v 显示详细的处理过程 选择参数 -S &quot;-S&lt;字尾备份字符串&gt;&quot; 或 &quot;--suffix=&lt;字尾备份字符串&gt;&quot; -V &quot;-V&lt;备份方式&gt;&quot; 或 &quot;--version-control=&lt;备份方式&gt;&quot; --version 显示版本信息 特点 ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其他文件都会发生相同的变化 软链接只会在选定的位置上生成一个文件的镜像，不会占用磁盘空间 硬链接会在选定的位置上生成一个和源文件相同大小的文件 无论是硬链接还是软链接，文件都保持同步变化 ln指令用在链接文件或目录，如果同时指定两个以上的文件或目录，则最后的目的地是一个已存在的目录（把前面指定的所有文件或目录复制到该目录中），否则会报错","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://Ison-Laihus.github.io/tags/Linux/"}]},{"title":"Ubuntu 下找不到动态链接库的原因","slug":"Ubuntu-下找不到动态链接库的原因","date":"2018-03-22T09:44:31.000Z","updated":"2018-03-22T10:02:00.435Z","comments":true,"path":"2018/03/22/Ubuntu-下找不到动态链接库的原因/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/22/Ubuntu-下找不到动态链接库的原因/","excerpt":"","text":"情况描述Linux下编程，下载所需要的安装包，解压，然后编译安装，通常命令： ./configure make sudo make install # 需要创建文件 当我们编译安装之后，到 /usr/local/lib 里和 /usr/local/include 里分别查看安装的库文件和头文件，然后我们欣喜的看到我们所安装的文件已经被放入到这里两个文件中，于是我们就去欣喜的写代码去了 ... coding ... 当我们的代码写好了之后，编译链接，然后运行，发下，它竟然提示: 找不到shared libraries ?!! 然后我们又反复的去 /usr/local/lib 中去查找，发现的确已经存在了。 于是我们思考是否是 /usr/local/lib 没有加入到 共享链接库的配置文件中。 于是我们打开 /etc/ld.so.conf 进行查看，发现： include /etc/ld.so.conf.d/*.conf /usr/local/lib 已经将 /usr/local/lib 包含进去了 解决办法执行下列命令 sudo ldconfig 重新加载一下所有的共享库文件，因为我们在安装好所需要的包之后，并没有给系统足够的时间来反应你所添加的内容，所以我们需要告诉系统应该重新加载一下。 之后再运行代码，OK了","categories":[],"tags":[{"name":"Linux  Ubuntu  C++","slug":"Linux-Ubuntu-C","permalink":"http://Ison-Laihus.github.io/tags/Linux-Ubuntu-C/"}]},{"title":"gcc 命令详解","slug":"gcc-命令详解","date":"2018-03-22T07:27:33.000Z","updated":"2018-03-22T15:13:15.075Z","comments":true,"path":"2018/03/22/gcc-命令详解/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/22/gcc-命令详解/","excerpt":"","text":"常用编译命令1. 无选项编译链接gcc test.c 将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。 2. 选项 -ogcc test.c -o test 将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。 3. 选项 -Egcc -E test.c -o test.i 将test.c预处理输出test.i文件。 4. 选项 -Sgcc -S test.i 将预处理输出文件test.i汇编成test.s文件。 5. 选项 -cgcc -c test.s 将汇编输出文件test.s编译输出test.o文件。 6. 无选项链接gcc test.o -o test 将编译输出文件test.o链接成最终可执行文件test。 7. 选项-Ogcc -O1 test.c -o test 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。 多源文件的编译方法1. 多个文件一起编译gcc testfun.c test.c -o test 将testfun.c 和 test.c 分别变异后连接成test可执行文件 2. 分别编译各个源文件，之后对编译后输出的目标文件链接gcc -c testfun.c gcc -c test.c gcc testfunc.o test.o -o test 库文件链接参考gcc编译命令","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://Ison-Laihus.github.io/tags/C/"}]},{"title":"了解CMake","slug":"了解cmake","date":"2018-03-21T08:18:36.000Z","updated":"2018-03-21T12:05:39.558Z","comments":true,"path":"2018/03/21/了解cmake/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/21/了解cmake/","excerpt":"","text":"什么是CMakeCMake允许开发者编写一种平台无关的CMakeList.txt文件来定制整个编译流程，然后在根据目标用户的平台进一步生成所需的本地化Makefile和工程文件。 其特点是： Write once, run everywhere. 使用CMake生成Makefile并编译的流程 编写CMake配置文件CMakeLists.txt 执行命令 cmake PATH 或者 ccmake PATH 生成 Makefile，其中 PATH 是CMakeLists.txt所在的目录。 使用make命令进行编译 ccmake 和 cmake 的区别在于前者提供了一个交互式的界面 CMakeLists.txt语法其由命令、注释和空格组成，其中命令是不区分大小写的。注释由 # 开头。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。 CMakeLists.txt常见命令一层目录cmake_minimum_required(VERSION 2.8) 指定运行此配置文件所需的CMake的最低版本为2.8一般项目的主CMakeLists.txt文件中一定有这个命令，子目录里不需要。 project(TEST) 表示项目的名称为TEST，主目录中的CMakeLists.txt文件中必须有，子目录中的CMakeLists.txt文件中不需要。 add_executable(Test main.cc) 将名为main.cc的源文件编译成一个名称为Test的可执行文件。如果需要将多个源文件编译成一个可执行文件，则添加到main.cc 的后面。更简便的方法如下： aux_source_direct(. DIR_SRCS) 查找 . 目录下（也就是当前目录下）的所有源文件，并将名称保存到DIR_SRCS变量中。编译时就可如下： add_executable(Test ${DIR_SRCS}) 多层目录add_subdirectory(sub) 当一个项目中有多层目录时，需要在上层CMakeLists.txt文件中添加子目录，并且子目录下也应当有CMakeLists.txt文件。这样一来，子目录下的CMakeLists.txt文件和源代码也会被处理。 aux_source_directory(. DIR_LIB_SRCS) add_library(MathFunctions ${DIR_LIB_SRCS}) 上面是子目录中CMakeLists.txt文件中的内容，其将子目录下的所有源文件编译为静态链接库。 set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions) target_link_libraries(Test ${EXTRA_LIBS}) 链接，当有子目录的时候，且子目录的代码是可执行文件的一部分而未被分离成另一个可执行文件，则需要链接它。 自定义编译选项Cmake允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。 cinfigure_file( &quot;${PROJECT_SOURCE_DIR}/config.h.in&quot; &quot;${PROJECT_BINARY_DIR}/config.h&quot; ) 该命令用于加入一个配置头文件config.h，这个文件有CMake从config.h.in生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。 config.h.in文件中的内容如下： #cmakedefine USE_MYMATH 其定义了变量USE_MYMATH，以供CMakeLists.txt文件使用。 option (USE_MYMATH &quot;Use provded math implementation&quot; ON) option命令添加了一个USE_MYMATH选项，并且设置了默认值为ON，中间的参数是对USE_MYMATH参数的描述。 设置为ON，则生成的config.h文件中就会定义出在config.h.in中配置的变量；设置为OFF，则生成的config.h文件中的定义就会被注释掉。 安装和测试CMake可以指定安装规则，以及添加测试。这两个功能分别可以通过产生Makefile后使用 make install 和 make test 来执行。 定制安装规则在子目录下的CMakeLists.txt文件中添加如下两行 install (TARGETS MathFunctions DESTINATION bin) install (FILES MathFunctions.h DESTINATION include) 在项目根目录下的CMakeLists.txt文件总添加如下两行 install (TARGETS Test DESTINATION bin) install (FILES &quot;${PROJECT_BINARY_DIR}/config.h&quot; DESTINATION include) 通过上面的定制，生成Test文件和MathFunctions函数库libMathFunctions.o文件将会被复制到 /usr/local/bin 中，而 MathFunctions.h和生成的config.h文件则会被复制到 /usr/local/include 中。 为工程添加测试CMake提供了一个称谓CTest的测试工具。我们只要在项目的根目录的CMakeLists.txt文件总调用一系列的 add_test 命令。 enable_testing() # 启用测试 在CMakeLists.txt文件的开头，需要添加这一行。 语法： add_test(TEST_NAME executable_file params) # 示例 add_test(test_run test 5, 2) add_test语法有两个以上的参数，第一个是自定义的测试命名，第二个是可执行文件名，其他的为可执行文件需要传入的参数。 set_tests_properties(自定义的测试名 PROPERTIES PASS_REGULAR_EXPRESSION 被包含的字符串) 这个语句是为了检测定义的测试的返回值中是否包含所给的字符串，PASS_REGULAR_EXPRESSION用来测试输出是否所给的字符串。 简化测试用例——宏定义 macro(do_test arg1 arg2 result) add_test (test_${arg1}_${arg2} Test ${arg1} ${arg2}) set_tests_properties(test_${arg1}_${arg2} PROPERTIES PASS_REGULAR_EXPRESSION ${result}) endmacro(do_test) do_test(5 2 &quot;is 25&quot;) do_test(5 2 &quot;is 25&quot;) do_test(5 2 &quot;is 25&quot;) do_test(5 2 &quot;is 25&quot;) 参考CMake入门实战在linux下使用CMake构建应用程序CMake简要教程","categories":[],"tags":[{"name":"工具 C++ cmake","slug":"工具-C-cmake","permalink":"http://Ison-Laihus.github.io/tags/工具-C-cmake/"}]},{"title":"Ubuntu16.04 + nginx + C++ + spawn-fcgi 开发web程序","slug":"Ubuntu16-04-nginx-C-spawn-fcgi-开发web程序","date":"2018-03-20T12:49:02.000Z","updated":"2018-03-20T15:23:34.280Z","comments":true,"path":"2018/03/20/Ubuntu16-04-nginx-C-spawn-fcgi-开发web程序/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/20/Ubuntu16-04-nginx-C-spawn-fcgi-开发web程序/","excerpt":"","text":"环境搭建系统：Ubuntu16.04nginx：1.13.9spawn-fcgi：1.6.4gcc：5.6 安装nginxnginx下载 解压后，进入nginx目录下，进行安装： ./configure 但是，在安装过程，可能会缺少一些安装包，例如pcre，zlib，OpenSSL，直接进行apt-get install 安装即可。 install make sudo make install # 注意需要root权限，因为需要创建文件 安装完成后，nginx放置在/usr/local/nginx目录下，主要的配置文件是其下的conf中的nginx.conf 安装spawn-fcgispawn-fcgi下载 解压后，进入spawn-fcgi目录 ./configure make 生成可执行文件之后，将其移动到nginx的sbin目录下 cp src/spaw-fcgi /usr/local/nginx/sbin 安装fcgi库fcgi库下载需要修改 /include/fcgio.h，添加如下代码 #include &lt;cstdio&gt; 然后，进行安装 ./configure make sudo make install # 注意需要root权限，因为需要创建文件 nginx命令启动服务 /usr/local/nginx/sbin/nginx start 关闭服务 spawn-fcgi命令","categories":[],"tags":[]},{"title":"Linux cURL命令记录","slug":"Linux-cURL命令记录","date":"2018-03-20T12:07:06.000Z","updated":"2018-03-20T12:34:27.116Z","comments":true,"path":"2018/03/20/Linux-cURL命令记录/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/20/Linux-cURL命令记录/","excerpt":"","text":"什么是cURLcURL，是linux中一个利用URL规则在命令行下工作的文件传输工具，是一款很强大的http命令行工具。语法 curl [option] [url] 常见参数 -A/--user-agent &lt;string&gt; 设置用户代理发送给服务器 -b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置 -c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到这个文件中 -C/--continue-at &lt;offset&gt; 断点续转 -D/--dump-header &lt;file&gt; 把header信息写入到该文件中 -e/--referer 来源网址 -f/--fail 链接失败时不显示http错误 -o/--output 把输出写到该文件中 -O/--remote-name 把输出写到该文件中，保留远程文件的文件名 -r/--range &lt;range&gt; 检索来自HTTP/1.1或FTP服务器字节范围 -s/--slient 静音模式，不输出任何东西 -T/--upload-file &lt;file&gt; 上传文件 -u/--user &lt;user[:password]&gt; 设置服务器的用户和秘密 -w/--write-out [format] 什么输出完成后 -x/--proxy &lt;host[:port]&gt; 在给定的端口上使用HTTP代理 -#/--progress-bar 进度条显示当前的传送状态","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://Ison-Laihus.github.io/tags/Linux/"}]},{"title":"浅谈CGI","slug":"浅谈CGI","date":"2018-03-20T11:40:46.000Z","updated":"2018-03-20T11:57:37.564Z","comments":true,"path":"2018/03/20/浅谈CGI/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/20/浅谈CGI/","excerpt":"","text":"文章参考：CGI,FastCGI,php-fpm之间的关系深入理解FastCGI协议","categories":[],"tags":[{"name":"网络 C++","slug":"网络-C","permalink":"http://Ison-Laihus.github.io/tags/网络-C/"}]},{"title":"JavaScript 继承","slug":"JavaScript-继承","date":"2018-03-19T14:08:10.000Z","updated":"2018-03-19T14:53:54.463Z","comments":true,"path":"2018/03/19/JavaScript-继承/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/19/JavaScript-继承/","excerpt":"","text":"许多OO语言都支持两种继承方式： 接口继承：只继承方法签名 实现继承：继承实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现继承主要依靠原型链来实现的。 function SuperType() { this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; this.property = true; } function SubType() { this.subProperty = true; } // 继承 SubType.prototype = new SuperType(); var instance = new SubType(); 两个问题： 包含引用类型值的原型，会被所有实例共享 在创建子类型的实例时，不能向超类型的构造函数中传递参数 借用构造函数原理：函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在新创建的对象上执行构造函数。 function SuperType() { this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } function SubType() { SuperType.call(this); } var instance = new SubType(); instance.colors.push(&quot;black&quot;); console.log(instance.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;] 传递参数相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。 问题方法都在构造函数中定义，因此函数复用就无从谈起了。在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都智能使用构造函数模式。 组合继承有时也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承。 function SuperType(name) { this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } SuperType.prototype.sayName = function() { console.log(this.name); } function SubType(name, age) { SuperType.call(this, name); // 第二次调用 SuperType() this.age = age; } SubType.prototype = new SuperType(); // 第一次调用 SuperType() SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() { console.log(this.age); } 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中做常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。 原型式继承借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。 function object(o) { function F(){} F.prototype = o; return new F(); } var person = { colors: [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;] }; // obj继承person对象 var obj = object(person); Object.create(fatherObj[, propertiesObj])ECMAScript5通过新增Object.create()方法规范化了原型继承。fatherObj: 要继承的父类对象propertiesObj: 和Object.defineProperties()中第二个参数一样，会覆盖原有同名属性。可选 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再想真的是它做了所有工作一样返回对象。 function createAnother(original) { var clone = object(original); clone.sayHi = function() { console.log(&quot;HI&quot;); } return clone; } 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。 前面的object()函数不是必须的，任何能够返回新对象的函数都适用于此模式。 使用寄生式继承来为对象添加函数，会由于不能做到函数服用而降低效率。这一点与构造函数模式类似 寄生组合式继承由于组合继承存在一个很大的缺陷： 其会调用两次超类型构造函数，一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 因为子类型最终会包含超类型对象的全部实例属性，所以我们不得不在调用子类型构造函数时重写这些属性。 解决办法：寄生组合式继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 背后的思路：不必为了指定子类型的原型而调用超类型的构造函数，我们需要的无非就是超类型原型的一个副本而已。 本质：使用寄生式继承来继承超类型的原型，然后在将结果指定给子类型的原型。 function inheritPrototype(subType, superType) { var prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象 } 这个例子能够保持原型链不变，还避免了在SubType.prototype上面创建不必要的、多余的属性。 这被普遍认为是引用类型最理想的继承范式。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://Ison-Laihus.github.io/tags/JavaScript/"}]},{"title":"'JavaScript严格模式'","slug":"JavaScript严格模式","date":"2018-03-18T07:54:43.000Z","updated":"2018-03-18T08:43:10.244Z","comments":true,"path":"2018/03/18/JavaScript严格模式/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/18/JavaScript严格模式/","excerpt":"","text":"ECMAScript5最早引入了“严格模式”（strict mode）的概念。通过严格模式，可以在函数内部选择进行较为严格的全局或局部的错误条件检测。 使用严格模式的好处：可以提早知道代码中存在的错误，即使捕获一些可能导致编程错误的ECMAScript行为。 选择使用选择进入严格模式，需使用严格模式的编译指示： &quot;use strict&quot;; 其其实是一个为负值的字符串字面量，支持严格模式的引擎会启动严格模式，不支持的就会忽略。 变量严格模式下，什么时候创建变量以及怎么创建变量都是有限制的。 不允许意外创建全局变量message = &quot;Hello&quot;; 这行代码在严格模式下是错误的。在严格模式下，如果给一个没有声明的变量复制，那代码在执行时就会抛出ReferenceError 不能对变量调用delete操作符var clolor = &quot;red&quot;; delete color; 在严格模式下上述代码会出错。虽在非严格模式下允许这样做，但是会静默失败（返回false） 严格模式下对变量有限制不能使用implements, interface, let, package, private, protected, public, static, yield作为变量名，这些都是保留字，将来的ECMAScript版本中可能会用到它们。 对象在严格模式下操作对象比在非严格模式下更容易导致错误。一般来说，在非严格模式下回静默失败的情形，在严格模式下回抛出错误。 在下列情形下操作对象的属性会导致错误： 为只读属性赋值——抛出TypeError 对不可配置的属性使用delete操作符——抛出TypeError 对不可扩展的对象添加属性——抛出TypeError 使用对象字面量时，属性名必须唯一var person = { name: &quot;xiaoming&quot;, name: &quot;honghong&quot; } 严格模式下报错，非严格模式下取第二个。 函数严格模式下的函数命名必须唯一。不能出现两个命名一样的函数，JavaScript中没有像C++中的函数重载。 严格模式下，arguments对象的行为也有所不同 非严格模式：arguments对象和命名参数双向绑定，改动任何一个，另一个的值也会随之改变 严格模式：arguments对象和命名参数无双向绑定 淘汰了arguments.callee 和 arguments.caller在非严格模式下，这两个属性一个引用函数本身，一个引用调用函数。在严格模式下，访问哪个属性都会抛出TypeError。 函数名不能使用保留字只能在脚本的顶级和在函数内部声明函数if (true) { function doSomething() { // ... } } 严格模式下，会导致语法错误。 eval()严格模式下，eval()在包含上下文中不再创建变量和函数。 function doSomething() { eval(&quot;var x = 10&quot;); alert(x); } 上述代码在严格模式下会抛出ReferenceError，因为x未被定义。 可以在eval()中声明变量和函数，但这些变量或函数只能被求值的特殊作用域中有效，随后就会被销毁。 &quot;use strict&quot;; var result = eval(&quot;var x=10, y = 11; x+y&quot;); console.log(result); // 21 上述代码是有效的。 eval和arguments严格模式已经明确禁止使用eval和arguments作为标识符，也不允许读写它们的值。而在非严格模式下是可以重写eval，也可以给arguments赋值。 抑制this在非严格模式下使用函数的apply()和call()方法时，null或undefined值会被转换为全局对象。 而在严格模式下，函数的this值始终是指定的值，无论指定的是什么值。 var color = &quot;red&quot;; function displayColor() { console.log(this.color); } displayColor.call(null); 非严格模式下输出red，this是全局对象严格模式下报错，this是null，对null操作报错 其他 抛弃了with语句——使用会导致语法错误 去掉了JavaScript中的八进制字面量","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://Ison-Laihus.github.io/tags/javascript/"}]},{"title":"人工智能笔记之人工智能概念","slug":"人工智能笔记之人工智能概念","date":"2018-01-02T12:04:33.000Z","updated":"2018-03-18T08:00:18.114Z","comments":true,"path":"2018/01/02/人工智能笔记之人工智能概念/","link":"","permalink":"http://Ison-Laihus.github.io/2018/01/02/人工智能笔记之人工智能概念/","excerpt":"","text":"人工智能分类| 像人一样思考 | 合理地（理性）思考 || 像人一样行动 | 合理地（理性）行动 | 像人一样行动：图灵测试自然语言处理，知识表示，自动推理，机器学习，计算机视觉，机器人学 像人一样思考：认知建模神经生理学实验，心理学实验，认知模型 理性地思考：思维法则逻辑学 理性地行动：理性智能体 理性行动：做正确的事 正确的事：在当前已有知识和前提条件下，能获得最佳期望结果的决定或行动 智能体是能感知和行动的实体 理性智能体智能体：指任何能通过传感器感知环境和通过执行器作用于环境的实体 理性智能体：对于每种可能的感知系列，理性智能体应该选择一个这样的动作来执行，此动作能在它所具有执行和感知序列提供的证据条件下，使得它的性能度量期望最大化。 理性有别于无所不知 智能体的设计在设计智能体时须首先明确的四大要素，简称PEAS 性能度量（Performance measure） 环境（Environment） 执行器（Actuators） 传感器（Sensors）","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://Ison-Laihus.github.io/tags/AI/"}]},{"title":"jQuery插件Datatables的使用","slug":"jQuery插件Datatables的使用","date":"2017-12-19T06:51:58.000Z","updated":"2017-12-19T08:24:15.533Z","comments":true,"path":"2017/12/19/jQuery插件Datatables的使用/","link":"","permalink":"http://Ison-Laihus.github.io/2017/12/19/jQuery插件Datatables的使用/","excerpt":"","text":"Datatables介绍Datatables是一款jquery表格插件，他是一个高度灵活的工具，可以将任何HTML表格添加高机的交互功能。特性： 分页，即时搜索和排序 几乎支持任何数据源：DOM，javascript，Ajax和服务器处理 支持不同的主题DataTables，JQuery UI，Bootstrap，Foundation 各式各样的扩展：Editor，TableTools，FixedColumns…… 丰富多样的option和强大的API 免费开源(MIT license) Datatables的使用Datatables的使用十分简单，只需要引入其提供给我们的css文件和js文件，我们就可以使用它了。这两个文件，你可以到官网上去下载，也可以直接使用它给我们提供的CDNcss1//cdn.datatables.net/1.10.15/css/jquery.dataTables.min.css js1//cdn.datatables.net/1.10.15/js/jquery.dataTables.min.js 当直接使用上述CDN时，一定需要开服务器，在服务器下运行html程序，否则不能正确定位到CDN如果不想开服务器，就想直接运行，请在css和js的CDN地址前加上一个http: 然后我们就可以尝试一下这个插件了！在html中写一个表格1234567891011121314151617181920212223242526&lt;table id=&quot;demo&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;column one&lt;/td&gt; &lt;td&gt;column two&lt;/td&gt; &lt;td&gt;column three&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;line one one&lt;/td&gt; &lt;td&gt;line one two&lt;/td&gt; &lt;td&gt;line one three&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;line two one&lt;/td&gt; &lt;td&gt;line two two&lt;/td&gt; &lt;td&gt;line two three&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;line three one&lt;/td&gt; &lt;td&gt;line three two&lt;/td&gt; &lt;td&gt;line three three&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 效果如下： 使用Datatables1$(&quot;#demo&quot;).DataTable(); 效果如下： 可以看到，Datatables这个插件自动帮我们加上了css样式，以及分页，搜索，排序等功能。 在使用Datatables的使用，一定要注意需要引入jquery，因为Datatables是基于jquery开发的。 使用Datatables加载数据在上述的例子中，我们是写好一个table，然后使用Datatables将他进行样式添加，功能添加的。但是如果每次都需要我们在HTML中手动添加数据，就会令人感觉十分繁琐，能不能有一种简单的方式来加载数据呢，实现数据与HTML分离，这样当数据进行变更时也方便修改。 答案是肯定的。Datatables能够自动加载数据，然后帮助我们生成dom元素填充到html中。使用这个功能时，html就只需要这么一行代码就OK了。1&lt;table id=&quot;demo&quot;&gt;&lt;/table&gt; 在javascript中使用数组存储数据源12345var dataSet = [ [&quot;line one one&quot;, &quot;line one two&quot;, &quot;line one three&quot;], [&quot;line two one&quot;, &quot;line two two&quot;, &quot;line two three&quot;], [&quot;line three one&quot;, &quot;line three two&quot;, &quot;line three three&quot;]]; 然后将其作为参数传入到Datatables的参数中12345678$(&quot;#demo&quot;).DataTable(&#123; data: dataSet, columns: [ // 定义每个列的标题 &#123;title: &quot;column one&quot;&#125;, &#123;title: &quot;column two&quot;&#125;, &#123;title: &quot;column three&quot;&#125; ]&#125;); 通过Ajax加载数据使用json格式将数据独立存储在文件中dataSet.json12345678910111213141516171819&#123; &quot;data&quot;: [ [ &quot;line one one&quot;, &quot;line one two&quot;, &quot;line one three&quot; ], [ &quot;line two one&quot;, &quot;line two two&quot;, &quot;line two three&quot; ], [ &quot;line three one&quot;, &quot;line three two&quot;, &quot;line three three&quot; ] ]&#125; 一定要注意，在使用json格式的数据，需要有一个名为data的key，这个key的value才是你要存放的数据数组 然后将其作为参数传入到Datatables的参数中12345678$(&quot;#demo&quot;).DataTable(&#123; ajax: &apos;dataSet.json&apos;, columns: [ // 定义每个列的标题 &#123;title: &quot;column one&quot;&#125;, &#123;title: &quot;column two&quot;&#125;, &#123;title: &quot;column three&quot;&#125; ]&#125;); 使用ajax的方式，一定得将html脚本运行在服务器上，否则不能成功加载 这个应该是应用得很广，在进行前后台交互的时候，我们可以直接使用这个功能，将后台传来的符合格式的数据直接通过Datatables加载到html页面上。 表格美化虽然面讲述了datatable的强大的功能，但是那界面未免令人不敢恭维。别担心，Datatables自知有这个缺点，索性它人品不错，和很多美工大师关系很好，我们能够直接以它的名义邀请他的朋友来帮忙。在这里，我们就直接邀请其非常有名的朋友，bootstrap来助我们一臂之力。 首先，我们得先引入bootstarp以及Datatables提供的和bootstrap一起工作的文件css12http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.csshttps://cdn.datatables.net/1.10.16/css/dataTables.bootstrap.min.css js1https://cdn.datatables.net/1.10.16/js/dataTables.bootstrap.min.js 然后，只需要改变html，给他加一个bootstrap提供的类名就行了1&lt;table id=&quot;demo&quot; class=&quot;table table-striped table-bordered&quot;&gt;&lt;/table&gt; 效果如下是不是好看了很多呢：） 至此，jQuery插件Datables的基本功能的使用已经介绍完了，Datatables还有很多其他的高级功能，后续博客，敬请期待！","categories":[],"tags":[{"name":"javascript plugins","slug":"javascript-plugins","permalink":"http://Ison-Laihus.github.io/tags/javascript-plugins/"}]},{"title":"XML介绍与实例","slug":"XML介绍与实例","date":"2017-12-18T12:16:24.000Z","updated":"2017-12-18T12:34:38.056Z","comments":true,"path":"2017/12/18/XML介绍与实例/","link":"","permalink":"http://Ison-Laihus.github.io/2017/12/18/XML介绍与实例/","excerpt":"","text":"简介XML是什么XML 是Extensible Markup Language的缩写，意思是可扩展标记语言。XML 是一个十分类似于HTML的语言。XML 是被设计来存储和传输数据的语言。XML 是一款自描述语言。 XML和HTML的差别XML和HTML是出于不同的目的而被设计出来的： XML被设计出来存储和传输数据——其专注于数据的内容 HTML被设计出来展示数据——其专注于数据的外观 XML标签是没有被预定义的，HTML标签是被预定义的 预定义就是提前设计好了，规定好了，你必须使用他设计好的标签，而不能使用别的没有预定义就是你可以随便自己定义标签，只要你觉得这个标签能描述出你所要描述的东西 XML仅仅是纯文本XML仅仅是携带数据的纯文本，有能力处理纯文本的软件都可以处理XML。 XML标签XML允许作者定义自己的标签和文档结构。 XML能干什么从HTML中分离数据当用HTML展示数据的时候，当数据改变时，你不一定非得修改HTML文件，你可以使用XML存储数据形成一个单独的文件，然后使用几行JavaScript代码从XML文件中读取数据填充到HTML中。当数据更新时，只需要修改XML文件即可，HTML文件的数据也会同步跟新。 HTML文件往往都很复杂，因为其中不仅仅只是包含数据，还包含一些动画，图片等需要复杂HTML标签才能展示的效果。在这些标签中寻找数据，往往十分困难。 简化数据共享XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。这让创建不同应用程序可以共享的数据变得更加容易。 简化数据传输因为任何系统都能够读取纯文本数据，因此通过XML可以在不兼容的系统之间轻松地交换数据。 实践关于XML的一些语法，我就不多加赘述了，如果大家感兴趣的话，可以去W3School上去学习。 下面，我们就使用代码来介绍一下如何使用XML进行数据的存储，应用于HTML程序。 首先，我们先使用XML存储我们想要显示的数据。例如，我想写一封邮件给我的同学，那么我就使用XML来存储关键的数据。1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;email&gt; &lt;from&gt;lyk&lt;/from&gt; &lt;to&gt;my friend&lt;/to&gt; &lt;title&gt;Thanks For Your Help&lt;/title&gt; &lt;content&gt;Yesterday, I forgot my pen in English test. You borrowed your pen to me. Thank your very much&lt;/content&gt; &lt;email&gt; 这里的所有标签都是我自己自己定义的 然后，我们就使用HTML来写一个网页来展示这些数据1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Email&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;title&quot;&gt;&lt;/div&gt; &lt;div class=&quot;subtitle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最后，我们使用JavaScript将XML中的数据填充到HTML页面中12","categories":[],"tags":[]},{"title":"github+hexo搭建个人博客","slug":"github-hexo搭建个人博客","date":"2017-12-08T16:29:07.000Z","updated":"2017-12-10T08:29:16.094Z","comments":true,"path":"2017/12/09/github-hexo搭建个人博客/","link":"","permalink":"http://Ison-Laihus.github.io/2017/12/09/github-hexo搭建个人博客/","excerpt":"","text":"步骤概览 注册一个github账号以及配置 在本地下载git，nodejs 下载hexo 在本地建立博客仓库 关联github page 选用主题 撰写博客 注册一个github账号以及配置我们的博客是由github+hexo搭建而成的，所以github必定是基础中的基础，前提中的前提。 什么是github？github是一个面向开元及私有软件项目的管理平台，因为只支持git作为唯一的版本库格式进行托管，故名github。 Step One首先，我们得去github去注册一个账号。 sign up 是注册， sign in 是登录 Step Two新建一个代码库，点击右上角的加号，点击New repository命名你要创建的代码库，这里需要注意，你代码库的名字一定得是yourname.github.io这里的yourname是你的账户名至于description，你可写可不写，然后点击最下方的create repository绿色按钮就OK了 Step Three设置代码库，开启gh-pages功能，这个功能是我们能够利用github搭建个人博客的重要功能。代码库创建成功之后，我们会进入如下界面：然后点击图片上部菜单末尾的settings属性，下滑到Github Pages设置这块由他的描述可知，github pages被设计为从Github库中托管您的个人、组织或项目页面。我们也获知其现在是无效的，需要我们往其中添加内容。我们可以点击下方的choose a theme按钮，然后选择你喜爱的风格：点击select theme按钮，它默认给你创建了一个issue，填充好了内容，然后你只需点击commit changes按钮即可 如果您完成了上述的工作，name恭喜你，你已经完成了第一部分的内容。然后您可以在浏览器的地址栏输入https://yourname.github.io查看您的项目页面。 在本地下载git，nodejs为甚我们需要下载git和nodejs呢？因为我们选用的hexo框架依赖于git和nodejs。 我们可以去git官网上去下载git。下载完成之后，双击安装即可。 强烈建议不要将其安装到C盘 然后一直next，知道finish 然后在桌面空白处点击右键，就会发现右键菜单中多出了Git GUI Here 和 Git Bash Here这两个选项 然后安装nodejs，官网网址点击.msi文件或是.zip文件均可，然后下载安装或解压。 要注意，需要配置环境变量在 控制面板 &gt; 系统和安全 &gt; 系统 &gt; 高级系统设置 &gt; 环境变量 &gt; 系统变量中的path &gt; 编辑 &gt; 新建 &gt; 将你安装node的文件路径复制然后一直点击确认即可 下载hexo什么是Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装hexo，打开命令行，执行如下命令 1npm install -g hexo 安装成功，可以执行hexo -v查看安装的版本 建立博客代码库新建一个文件夹，cmd运行进入到该目录下，使用hexo init命令初始化代码库然后使用如下命令1npm install --save hexo-deployer-git 安装所需的一些依赖包 运行博客 清除缓存文件 1hexo clean 生成静态文件 1hexo generate 或 hexo g 启动服务器 1hexo server 执行完上述命令，打开浏览器，输入http://localhost:4000，即可看到稍微满意的结果 关联github page配置git个人信息打开git bash，输入如下命令：12git config --global user.name &quot;xxx&quot; git config --global user.emal &quot;xxx@xxx.xxx&quot; 将其中的xxx替换成您自己的信息 然后使用如下命令生成秘钥：1ssh-keygen -t rsa -C &quot;your email&quot; 请将your email替换成您自己的邮箱 执行完毕，就会在C盘的用户目录下生成一个.ssh文件夹，其中会有id_rsa和id_rsa.pub这两个文件，分别是私钥和公钥 添加生成的秘钥到到ssh-agent12eval `ssh-agent -s` # 启动ssh-agent ssh-add # 添加秘钥 将公钥复制，进入github settings中的Deploy Keys选项，点击Add Deploy Key按钮将公钥复制到Key文本栏中，title栏可以任意填点击 Add Key即可 这是为了避免您每次想github推送您更新的博客时，都需要输入您的用户名和密码，配置公钥私钥能够让git自动帮您进行认证 配置Deployment在您博客代码库的根目录下有一个_config.yml文件，这是您网站的配置文件。您需要进行一些修改以匹配您的git page1234deploy: type: git repo: git@github.com:Ison-Laihus/Ison-Laihus.github.io.git branch: master 请进行相应的替换 在_config.yml文件中还有其他一些参数可以配置例如： 修改博客站点信息1234567# Sitetitle: Ison Blog subtitle: happy to have a blog description:author: Ison language:timezone: 将本地博客部署到github pages部署命令1hexo deploy 或 hexo d 但是需要注意，在部署之前，需要先进行清除缓存和生成静态文件的命令 然后再浏览器中输入URL: https://yourname.gihub.io，就会发现已经将本地博客部署到github上了 选用主题在github上，有许许多多github的主题，您可以在github上进行搜索 您可以选择您喜爱的主题，然后下载到本地博客代码仓库themes文件夹下 例如，我们选择hexo-theme-even这个主题，然后使用git bash从github上克隆下来12npm install hexo-renderer-scss --save # 首先安装依赖的包 git clone git@github.com:ahonn/hexo-theme-even.git themes/even 后面的themes/even请根据您的自身情况进行修改 然后修改_config.yml文件中的theme字段，因为我们将下载的主题命名为even，所以我们将这个字段设置为even 然后清除缓存，生成静态文件，部署在浏览器输入URL: https://yourname.gihub.io，发现博客主题已经被更改，但是却很糟糕 这里不知道是不是作者写错了还是怎么，不过我们可以做一些修改： 进入主题even的文件夹中，进入layout/_partial文件夹下，打开head.swig文件，将如下两行代码做些修改123&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;&#123;&#123; url_for(theme.favicon) &#125;&#125;?v=&#123;&#123; theme.version &#125;&#125;&quot; /&gt; ··· &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;&#123; url_for(&apos;css/style.css&apos;) &#125;&#125;?v=&#123;&#123; theme.version &#125;&#125;&quot; /&gt; 修改成123&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;&#123;&#123; url_for(theme.favicon) &#125;&#125;&quot; /&gt; ··· &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;&#123; url_for(&apos;css/style.css&apos;) &#125;&#125;&quot; /&gt; 然后执行必备的三步，即可看到炫酷的效果 是不是很酷炫呢:) 撰写博客终于到了我们最后一个模块了——撰写博客 hexo有一个新建博客文章的命令1hexo new &lt;title&gt; 该命令会自动在source/_post文件夹下生成一个markdown文件，然后我们可以使用Markown编辑器打开这个文件进行编辑，撰写我们的博客。 这似乎很简单，但是这并不是我所要说的重点。 我所说的重点是，如何在我们的博客代码仓库存储我们的数据文件，例如，如果有一张图片，我们该怎么保存在我们的图片呢？ 不要着急，hexo给我们提供了这个功能。 我们只需要在根目录下的_config.yml中修改post_asset_folder的字段设置为true1post_asset_folder: true 然后当我们使用新建博客文章的命令的同时，会在source/_post目录下生成一个与你博客文章同名的文件夹，你可以将你的数据文件放入这个文件夹中，然后使用如下命令进行引用：1&#123;% asset_img example.jpg This is an example image %&#125; asset_img是不能更改的，example.jpg根据您的图片名称进行修改，This is an example是描述语句，可以任意更改。 结语至此，使用github+hexo搭建个人博客已经完成，如果有误，希望指正。更多内容，请参考hexo官方文档","categories":[],"tags":[{"name":"部署","slug":"部署","permalink":"http://Ison-Laihus.github.io/tags/部署/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-07T12:53:43.641Z","updated":"2017-12-07T12:53:43.641Z","comments":true,"path":"2017/12/07/hello-world/","link":"","permalink":"http://Ison-Laihus.github.io/2017/12/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]