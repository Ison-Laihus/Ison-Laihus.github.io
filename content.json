[{"title":"Hello World","slug":"hello-world","date":"2018-05-31T06:43:37.363Z","updated":"2017-12-07T12:53:43.641Z","comments":true,"path":"2018/05/31/hello-world/","link":"","permalink":"http://Ison-Laihus.github.io/2018/05/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"HTTP 状态码","slug":"HTTP-状态码","date":"2018-05-06T06:49:42.000Z","updated":"2018-05-06T06:57:57.512Z","comments":true,"path":"2018/05/06/HTTP-状态码/","link":"","permalink":"http://Ison-Laihus.github.io/2018/05/06/HTTP-状态码/","excerpt":"","text":"HTTP状态码类型 信息类（1**） 响应成功类（2**） 重定向类（3**） 客户端错误类（4**） 服务端错误类（5**） 信息类（1**） 状态码 描述 100 客户端必须继续发出请求 101 客户端要求服务器根据请求转换HTTP协议版本 102 处理将会被继续执行 响应成功类（2**） 状态码 描述 200 表明请求被成功完成，所请求的资源发送回客户端 201 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。 202 服务器已接受请求，但尚未处理。 203 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://Ison-Laihus.github.io/tags/HTTP/"}]},{"title":"JavaScript 数组的方法","slug":"JavaScript-数组的方法","date":"2018-05-05T10:25:05.000Z","updated":"2018-05-05T14:40:36.894Z","comments":true,"path":"2018/05/05/JavaScript-数组的方法/","link":"","permalink":"http://Ison-Laihus.github.io/2018/05/05/JavaScript-数组的方法/","excerpt":"","text":"目录32个方法：toString()、toLocaleString()、valueOf()、join()、push()、pop()、shift()、unshift()、reverse()、sort()、concat()、slice()、splice()、indexOf()、lastIndexOf()、reduce()、reduceRight()、map()、forEach()、filter()、some()、every()、Array.from()、Array.of()、copyEithin()、find()、findIndex()、fill()、entries()、keys()、values()、includes() 继承的方法toString()返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。 toLocaleString()是toString()方法的本地化版本，它经常也会返回toString()方法相同的值。但是在将Date对象转换为字符串的话，就会根据本地的时间进行转换。 undefined 和 null 在使用上述两种方法时会转换为 空字符串 valueOf返回数组对象本身 数组转换方法joinArray.join()方法时Sting.split()方法的逆向操作，是将数组中的元素以一个连接符连接成一个字符串。默认是 , ，也可以传入分隔符作为join的参数。null 和 undefined 会被视为 空字符串。 栈和队列方法push可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 使用apply方法可以合并两数组 123let a = [1, 2, 3]let b = [4, 5, 6]Array.prototype.push.apply(a, b) // [1, 2, 3, 4, 5, 6] 但是，使用call方法，却会将数组看成一个整体 123let a = [1, 2, 3]let b = [4, 5, 6]Array.prototype.push.call(a, b) // [1, 2, 3, [4, 5, 6] ] pop从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。 对空数组使用pop()方法，不会报错，而是返回undefined shift移除数组中的第一个项并返回该项，同时数组的长度减一。 对空数组使用shift()方法，不会报错，而是返回undefined unshift在数组前端添加任意个项，并返回新数组的长度。 当使用多个参数调用unshift()时，参数是一次性插入的而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致 数组排序方法reverse用户反转数组的顺序，返回经过排序之后的数组，而且原数组顺序也会发生改变。 sort按字符串升序排列数组项，sort方法会调用每个数组项的toString()方法，然后比较得到的字符串排序，返回经过排序之后的数组，而原数组顺序也发生改变。 如果数组中包含undefined元素，它们会被排到数组的尾部 sort()方法可以接受一个比较函数作为参数，以便指定哪个值在哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个参数之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后则返回一个正数 如果对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将参数转化为小写字符串再开始比较 数组拼接方法concat基于当前数组中的所有项创建一个新数组，先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。所以concat()不影响原数组。 如果不给concat()方法传递参数时，它只是复制当前的数组；如果参数是一个或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中；如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。 如果不提供参数，concat()方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是如果数组成员包括复合类型的值（比如对象），则新数组拷贝的是该值的引用。 创建子数组slice(start, end)基于当前数组中的一个或多个项创建一个新数组，接受一个或两个参数，即要返回项的起始和结束位置，最后返回新数组，所以slice()不影响原数组。 slice(start,end)方法需要两个参数start和end，返回这个数组中从start位置到(但不包含)end位置的一个子数组；如果end为undefined或不存在，则返回从start位置到数组结尾的所有项。 如果start是负数，则start = max(length + start,0)。 如果end是负数，则end = max(length + end,0)。 如果没有参数，则返回原数组。 slice()方法涉及到Number()转型函数的隐式类型转换，当start被转换为NaN时，相当于start = 0；当end被转换为NaN时(end为undefined除外)，则输出空数组。 数组删改方法splice(start, length, item1, …, itemX)用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，该方法会改变原数组。 不提供第二个参数的时候，默认到结尾。 item1,…,itemX 会用来替换被删除掉的数组项。 数组位置方法indexOf(search, start)从start位置开始向后搜索search，返回search第一次出现的位置下标，没有则返回-1。 lastIndexOf(search, start)从start位置开始向后搜索search，返回search最后一次出现的位置下标，没有则返回-1 数组归并方法reducereduce()方法需要两个参数。 第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。 化简函数接受四个参数，分别是： 初始变量，默认为数组的第一个元素值。函数第一次执行后的返回值作为函数第二次执行的初始变量，依次类推 当前变量，如果指定了第二个参数，则该变量为数组的第一个元素的值，否则，为第二个元素的值 当前变量对应的元素在数组中的索引(从0开始) 原数组对象 化简函数的这四个参数之中，只有前两个是必须的，后两个则是可选的。 第二个(可选)的参数是一个传递给函数的初始值。 reduceRightreduceRight()的工作原理和reduce()一样，不同的是它按照数组索引从高到低（从右到左）处理数组，而不是从低到高。 数组迭代方法map对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组。 map()方法还可以接受第二个参数，表示回调函数执行时this所指向的对象。 12var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];[1,2].map(function(item,index,arr)&#123;return this[item]&#125;,arr);//[&apos;b&apos;,&apos;c&apos;] forEach()方法除了接受一个必须的回调函数参数，第二个参数还可以接受一个可选的上下文参数(改变回调函数里面的this指向)。第二个参数对于多层this非常有用，因为多层this通常指向是不一致的，可以使用forEach()方法的第二个参数固定this。 12345var out = [];[1, 2, 3].forEach(function(elem)&#123;this.push(elem * elem);&#125;, out);console.log(out);// [1, 4, 9] forEach对数组中的每一项运行给定函数，这个方法没有返回值。本质上与for循环迭代数组一样。如果需要有返回值，一般使用map方法。 filter对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。该方法常用于查询符合条件的所有数组项。 filter()方法还可以接受第二个参数，指定测试函数所在的上下文对象(this对象)。 filter()会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的，所以可以压缩稀疏数组的空缺。 some对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false。 everyevery()方法对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true；只要有一项返回false，则返回false。 ES6扩展运算符 …将一个数组转为用逗号分隔的参数序列。 Array.from()用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象。 类似数组的对象必须有length参数 12345678var arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;var arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] Array.of()用于将一组值转换为数组。 12Array.of(3, 11, 8) // [3, 11, 8]Array.of(3, 11, 8).length // 3 copyEithin(target, start=0, end=this.length)数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 target（必需）：从该位置开始替换数据。start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] find() &amp; findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 fill()使用给定值，填充一个数组。 12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7) // [7, 7, 7][&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7) // [7, 7, 7] fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 1[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2) // [&apos;a&apos;, 7, &apos;c&apos;] entries() &amp; keys() &amp; values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 12345for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot; 如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。 12345var letter = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];var entries = letter.entries();console.log(entries.next().value); // [0, &apos;a&apos;]console.log(entries.next().value); // [1, &apos;b&apos;]console.log(entries.next().value); // [2, &apos;c&apos;] includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。 1[1, 2, 3].includes(2) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://Ison-Laihus.github.io/tags/javascript/"}]},{"title":"C++ 输出控制格式","slug":"C-输出控制格式","date":"2018-05-04T08:05:01.000Z","updated":"2018-05-04T08:45:30.148Z","comments":true,"path":"2018/05/04/C-输出控制格式/","link":"","permalink":"http://Ison-Laihus.github.io/2018/05/04/C-输出控制格式/","excerpt":"","text":"输入输出流的控制符 控制符 作用 dec 设置数值的技术为10 hex 设置数值的技术为16 oct 设置数值的技术为8 setfill(c) 设置填充字符c，c可以是字符常量或字符变量 setprecision(n) 设置浮点数的精度为n位。在以一般十进制小数形式输出时，n代表有效数字。在以fixed（固定小数位数）形式和scientific（指数）形式输出时，n为小数位数 setw(n) 设置字段宽度为n位 setiosflags(ios::fixed) 设置浮点数以固定的小数位数显示 setiosflags(ios::scientific) 设置浮点数以科学计数法（即指数形式）显示 setiosflags(ios::left) 输出数据左对齐 setiosflags(ios::right) 输出数据右对齐 setiosflags(ios::skipws) 忽略前导的空格 setiosflags(ios::uppercase) 数据以十六进制形式输出时字母以大写表示 setiosflags(ios::lowercase) 数据以十六进制形式输出时字母以小写表示 setiosflags(ios::showpos) 输出正数的时候给出 “+” 号 流控制成员函数 流成员函数 与之作用相同的控制符 作用 precision(n) setprocision(n) 设置实数的精度为n位 width(n) setw(n) 设置字段宽度为n位 fill(c) setfill(c) 设置填充字符c setf() setiosflags() 设置输出格式状态 unsetf() resetioflags() 终止已设置的输出格式状态，在括号中指定内容 设置格式状态的格式标志 格式标志 作用 ios::left 输出数据在本域宽范围内向左对齐 ios::right 输出数据在本域宽范围内向右对齐 ios::internal 数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充 ios::dec 设置整数的基数为10 ios::oct 设置整数的基数为8 ios::hex 设置整数的基数为16 ios::showbase 强制输出整数的基数（八进制以0打头，十六进制以0x打头） ios::showpoint 强制输出浮点数的小数点和尾数0 ios::uppercase 在以科学计数法格式E和以十六进制输出字母时以大写表示 ios::lowercase 在以科学计数法格式e和以十六进制输出字母时以小写表示 ios::showpos 对正数显示 “+” 号 ios::scientific 浮点数以科学计数法格式输出 ios::fixed 浮点数以定点格式（小数形式）输出 ios::unitbuf 每次输出之后刷新所有的流 ios::stdio 每次输出之后清除所有的流","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://Ison-Laihus.github.io/tags/C/"}]},{"title":"Linux 常用命令记录","slug":"Linux-常用命令记录","date":"2018-04-22T06:16:08.000Z","updated":"2018-06-03T07:11:58.536Z","comments":true,"path":"2018/04/22/Linux-常用命令记录/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/22/Linux-常用命令记录/","excerpt":"","text":"查看linux的系统位数1uname -a 若返回的内容有 x86_64 的字样，则是64位系统。若返回的内容有 i386 的字样，则是32位系统。 下载文件建议使用wget下载，curl一般是模拟提交web数据。 1wget -o [保存在本地的文件或文件夹名称] URL wget命令大全：http://www.cnblogs.com/peida/archive/2013/03/18/2965369.html wget和curl区别： https://blog.csdn.net/hzraymond/article/details/8181349 查看文件夹或目录大小12345du [目录] # 显示字节大小du -k [目录] # 以k为单位du -m [目录] # 以M为单位du -h [目录] # 以G为单位du -h --max-depth=1 [目录] # 只往下一层计算大小 参考： https://blog.csdn.net/ouyang_peng/article/details/10414499 修改文件或目录名 使用mv命令 mv [原命名] [新命名] 使用rename命令 rename &apos;[源字符]&apos; &apos;[替换字符]&apos; * 查看linux版本内核版本123cat /proc/versionuname -runame -a 发行版本1lsb_release -a 超级用户密码设置在安装了linux系统之后，忘记了设置密码，怎么办？linux有默认密码么？ linux的root默认密码是随机的，每次开机都有一个新的root密码。 解决办法： 1sudo passwd 该命令可以修改root的密码 快捷键Ctrl + H 显示/隐藏 隐藏文件","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://Ison-Laihus.github.io/tags/Linux/"}]},{"title":"PHP CURL","slug":"PHP-CURL","date":"2018-04-22T03:35:54.000Z","updated":"2018-04-24T13:44:16.604Z","comments":true,"path":"2018/04/22/PHP-CURL/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/22/PHP-CURL/","excerpt":"","text":"PHP CURL介绍PHP 的 CURL 是 PHP 的 Client URL 库。 CURL语法一个简单的例子123456789101112131415&lt;?php$ch = curl_init(&quot;http://baidu.com&quot;); # 初始化一个curl会话，并给予其要访问的网址$fp = fopen(&quot;baidu_ctx&quot;, &quot;w&quot;); # 打开一个本地文件curl_setopt($ch, CURLOPT_FILE, $fp); # 设置curl获取URL的资源后存储的文件属性curl_setopt($ch, CURLOPT_HEADER, 0); # 设置curl header属性为空curl_exec($ch); # 执行curl的设定，访问urlif ( curl_errno($ch) ) &#123; # 返回最后一次错误代码 echo &quot;error: &quot; . curl_error($ch); # 返回当前会话最后一次错误的字符串&#125;curl_close($ch); # 关闭curl会话fclose($fp); # 关闭文件 在这里，我们已经学习到了CURL的几个重要的函数了： curl_init, curl_setopt, curl_exec, curl_close。 下面，让我们来一一介绍。 curl_init: 初始化一个curl会话，其可以在初始化会话的时候传入URL信息，也可以不传入，改为用curl_setopt设置，如下 $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt: 设置会话的一些属性，这个函数特别重要，因为在访问大多数网站的时候，必须得设置一些属性才能够访问 curl_exec: 会话初始化并设置完属性之后，就可以执行这个会话，去向相应的url发出请求了 curl_errno: 返回最后一次错误代码，判断请求是否失败 curl_error: 返回当前会话最后一次错误的字符串 curl_close: 关闭curl会话 如何访问HTTPS资源参考： http://www.jackxiang.com/post/2653/ 访问HTTPS资源，前提是你本地PHP安装了openssl扩展。然后，在代码中设置会话的这两个属性即可： curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0); # 设置curl ssl verify host 属性为空 curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); # 设置curl ssl verify peer 属性为空 ####","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://Ison-Laihus.github.io/tags/PHP/"}]},{"title":"Linux 下关机命令","slug":"Linux-下关机命令","date":"2018-04-18T15:52:00.000Z","updated":"2018-04-18T16:03:57.770Z","comments":true,"path":"2018/04/18/Linux-下关机命令/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/18/Linux-下关机命令/","excerpt":"","text":"命令列表 shutdown halt reboot init shutdownshutdown命令通常必须由超级用户才能执行。 shutdown命令执行后，会以广播的形式通知正在系统中工作的所有用户，系统将在指定的时间内关闭,请用户保存文件，停止作业，注销用户。此时login指令被冻结，新的用户不能登录。 语法： shutdown [-fFhknc(参数名称)] [-t描述] 时间 [警告信息] 123456789-f: 重启系统时不执行fsck-F: 重启是执行fsck-h: 将系统关闭，相当于halt命令-k: 只是送出信息给所有用户，但不会真正关机-n: 不调用init程序关机，而是由shutdown自己进行，使用此类参数将加快关机速度，但是不建议用户使用此种关机方式-r: shutdown之后重新启动系统-c: 取消一个shutdown命令-t&lt;秒数&gt;: 送出警告信息和关机信号之间要延迟多少秒[警告信息]: 要传送给所有登录用户的信息 示例： shutdown 16:50 # 在16:50执行shutdown关机 shutdown -r now # 立即 重启系统 shutdown -h now # 立即 关机 shutdown +5 &quot;system will shutdown after 5 minutes&quot; # 设定5分钟后关机，同时发出警告信息给登录用户 halthalt是最简单的关机命令，相当于“shutdown -h”组合。 halt’执行时，将杀死所有应用程序，然后调用系统指令sync。sync将所有内存信息通过文件系统写入硬盘，然后停止内核。 语法： halt [-finp] 1234-f: 不管当前系统处于何种运行级别，不调用shutdown而强制关机。-i: 关机之前，关掉所有的网络接口。-n: halt执行时，不调用系统指令sync。-p: 关机时调用poweroff，也就是关机时同时关闭电源。此选项为缺省选项。 halt指令在执行时，会首先检测系统的运行级别，如果运行级为0或6，则立即关闭系统，否则调用shutdown来关闭系统。 rebootreboot命令的执行过程与halt基本类似，不同的是halt是用于关机，而reboot是关机后引发系统重启。 initinit程序主要用于系统不用运行级之间的切换。 示例： init 0 # 将系统运行级切换到0，也就是关机 init 6 # 将系统运行级切换到6，也就是重启系统","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://Ison-Laihus.github.io/tags/Linux/"}]},{"title":"Linux 初始化服务init的配置文件inittab","slug":"Linux-初始化服务init的配置文件inittab","date":"2018-04-18T15:20:25.000Z","updated":"2018-04-18T15:51:06.483Z","comments":true,"path":"2018/04/18/Linux-初始化服务init的配置文件inittab/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/18/Linux-初始化服务init的配置文件inittab/","excerpt":"","text":"Linux操作系统系统启动流程 加电开机 硬件自检 配置基本设备 装载内核引导镜像 配置其他设备 初始化服务init（/etc/inittab） linux在完成核内引导以后，就开始运行init程序。init程序进程号是1，是所有进程的起点。 inittab文件中值的格式label:runlevel:action:process labellabel一般是1-2个字符标签，用来标示输入的值。 常用的值如下： 1234567id: 用来定义缺省的init运行的级别si: 是系统初始化的进程ln: 其中n是从1~6，指明该进程可以使用的runlevel的级别ca: 指明当按下Ctrl+Alt+Del时运行的进程pf: 指“当UPS表明断电”时运行的进程pr: 是在系统真正关闭之前，UPS发出电源回复信号时需要运行的进程x: 是将系统转入X终端时需要运行的进程 actionaction字段定义了该进程应该运行在何种状态下。 其常见的取值和含义如下： 123456789boot: 在系统启动时运行忽略runlevelbootwait: 在系统启动时运行，init等待进程完成。忽略runlevelctrlaltdel: 当Ctrl+Alt+Del三个键同时按下时运行，把SIGINT信号发送给initinitdefault: 不要执行这个进程，它用于设置默认runleveloff: 禁止进入，因此该进程不运行once: 运行一次respawn: 不管何时终止都重新启动进程sysinit: 在运行boot或bootwait进程之前运行wait: 需等待其运行完毕再运行其他项 processprocess字段包含init执行的进程，该进程采用的格式与在命令行下运行该进程的格式一样。 因此process字段都以该进程的名字开头，紧跟着是运行时要传递给该进程的参数。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://Ison-Laihus.github.io/tags/Linux/"}]},{"title":"node package.json 语法笔记","slug":"node-package-json-语法笔记","date":"2018-04-16T11:47:10.000Z","updated":"2018-04-17T08:57:36.793Z","comments":true,"path":"2018/04/16/node-package-json-语法笔记/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/16/node-package-json-语法笔记/","excerpt":"","text":"npm简介npm，全称：Node Package Manager，即包管理工具。其是Node.js默认的，以JavaScript编写的软件包管理系统。 package.json介绍npm进行包管理，需要有一些已经写好的规则，npm会读取这个规则文件，然后进行包的安装。而这个规则文件，就是pacakge.json。 举个例子：npm 和 package.json的关系就像是 Make 和 Makefile之间的关系。 语法在package.json中，有一些字段，这些字段十分重要，就是这些字段告知npm该要做什么。 package.json中，name 和 version 字段是必须字段，没有这两个字段，npm是不可能工作的。 这些字段忽略大小写 name标志你的项目名称。 一些规则： 名字必须不大于214个字符，这个限定包括项目包含的包的名称 名字不能以 . 或 _ 开始 新包的名称中不能有大写字母 该名称最终会在成为URL的一部分，命令行参数 和 文件夹名称，因此，其不能包含任何非URL安全字符 一些提示： 别将项目名称命名为与Node核心模块同样的名称 别把 js 或 node 放在名字中 项目名称会被作为 require() 的一个参数，所以它应该尽量短且有说明性 version标志项目的版本。和那么一起唯一标志一个项目。 name 和 version 一起 标志了一个项目，就像是一个项目的ID，不存在任何项目的 name 和 version完全相同。 description用来描述这个项目，其是一个字符串。它可以帮助人们发些它，当我们在npm官网上搜索项目或使用 npm search 时，会匹配description。 keywords项目关键字。同description一般，帮助人们发现这个项目。 homepage项目主页的URL。 bugs他的值是一个对象，这个对象中有两个字段，url 和 email，其含义是人们发现这个项目的问题的时候，可以去访问这个url或是联系这个email。 示例： { &quot;url&quot;: &quot;http://github.com/owner/project/issues&quot;, &quot;email&quot;: &quot;project@hostname.com&quot; } license标志这个项目的使用权限。 如 BSD-2，MIT，SPDX等。 authorauthor是标志一个人的名字，表示项目的作者。 contributorscontributors是一组人的名字，是一个数组，表示项目的作者。 files可选字段，是一个文件模式的数组， 它描述当你的项目作为一个依赖包被安装时所需包含的条目。 你可以写一个.npmignore的文件来告诉npm不应该包含哪些文件或目录，但当项目中有.gitignore时，就以.gitignore为准。 但是，得注意，.npmignore和.gitignore不会将package.json中files字段所设置的文件或目录，即使他们中有写，也会被忽略。 有一些文件是无论如何设置都会被包含的： 123456package.jsonREADMECHANGES/CHANGELOG/HISTORYLICENSE/LICENCENOTICEmain字段标志的文件 有一些文件是无论如何设置，都会被忽略的： 123456789101112131415.gitCVS.svn.hg.lock-wscript.wafpickle-N.*.swp.DS_Store._*npm-debug.log.npmrcnode_modulesconfig.gypi*.origpackage-lock.json main其标志了这个项目的主要入口文件。 browser如果你的项目是客户端项目，那么这个browser字段就应该替换掉main字段。 repository指定代码所在的位置。 示例： &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;, &quot;https://github.com/npm/npm.git&quot; } 对于github，github gist，bitbucket，gitlab，可以对repository的值进行缩写： &quot;repository&quot;: &quot;github:user/repo&quot; &quot;repository&quot;: &quot;gist:11081aaa281&quot; &quot;repository&quot;: &quot;bitbucket:user/repo&quot; &quot;repository&quot;: &quot;gitlab:user/repo&quot; srcipts其是一个包含脚本命令的字典，它在您的包的生命周期中的不同时间运行。 dependencies其用一个简单的对象来将包映射到一个版本范围。 版本范围语法： 1234567891011version: 精确匹配&gt;version: 大于该版本 &gt;=version: 大于等于该版本&lt;version: &lt;=version:~version: 大约相当于该版本^version: 兼容该版本1.2.x: *: 所有版本均可&quot;&quot;(空): 和*一样version1 - version2: version1和version2之间 参考更多详细信息，请查阅官方文档https://docs.npmjs.com/files/package.json","categories":[],"tags":[{"name":"node npm pakage.json","slug":"node-npm-pakage-json","permalink":"http://Ison-Laihus.github.io/tags/node-npm-pakage-json/"}]},{"title":"Linux 下备份和恢复技术","slug":"Linux-下备份和恢复技术","date":"2018-04-13T13:10:53.000Z","updated":"2018-04-13T15:06:43.811Z","comments":true,"path":"2018/04/13/Linux-下备份和恢复技术/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/13/Linux-下备份和恢复技术/","excerpt":"","text":"前言数据有丢失的风险，因此文件的备份十分重要。 在Linux下，一般来说，一下目录是需要备份的： 12345/etc ： 包含所有核心配置文件。/var ： 包含系统守护进程（服务）所使用的信息，包括DNS配置，DHCP租期、邮件缓冲文件、HTTP服务器文件、db2实例配置等。/home ： 包含所有用户的默认用户主目录。/root ： 是超级用户（root）的主目录。/opt ： 是安装许多非文件系统的地方。 而有些目录应该考虑不备份的： 123/proc ： 它不是一个真实的文件系统，而是运行内核和环境的虚拟化视图。应该永远不要备份这个目录。 /dev ： 包含硬件设备的文件表示。如果计划还原到一个空白的系统，那就可以备份 /dev。然而，如果计划还原到一个已安装的 Linux 系统，那么备份 /dev 是没有必要的。其他目录 ： 其他目录包含系统文件和已经安装的包。在服务器环境中，这其中的许多信息都不是自定义的。大多数自定义都发生在 /etc 和/home 目录中。 备份技术tar [主选项+辅选项] 文件或者目录 主选项 123c ： 创建新的档案文件x ： 从档案文件中释放文件t ： 列出档案文件的内容，查看已经备份了哪些文件 上述三个参数 c/x/t 仅能存在一个，不能同时存在，因为不可能同时压缩和解压缩。 辅助选项 1234-z ： 是否需要用gzip压缩或解压，一般格式为xxx.tar.gz或xx.tgz-j ： 是否需要用bzip2压缩或解压，一般格式为xx.tar.bz2-v ： 压缩的过程中显示文件--exclude FILE ： 在压缩的过程中，不要将FILE打包 打包压缩示例 1234# tar -cvf /tmp/etc.tar /etc # 仅打包# tar -zcvf /tmp/etc.tar.gz /etc # 打包后，以gzip压缩# tar -jcvf /tmp/etc.tar.bz2 /etc # 打包后，以bzig2压缩# tar --exclude /home/user001 -zcvf myfile.tar.gz /home/* /etc # 备份/home目录下除user001的所由文件目录和/etc目录 解压示例 12# tar -ztvf /tmp/etc.tar.gz# tar -jtvf /tmp/etc.tar.bz2","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://Ison-Laihus.github.io/tags/Linux/"}]},{"title":"C++ static详解","slug":"C-static详解","date":"2018-04-13T12:58:36.000Z","updated":"2018-04-13T12:58:36.330Z","comments":true,"path":"2018/04/13/C-static详解/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/13/C-static详解/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"网络、群体与市场笔记","slug":"网络、群体与市场笔记","date":"2018-04-11T10:34:48.000Z","updated":"2018-04-11T12:19:33.731Z","comments":true,"path":"2018/04/11/网络、群体与市场笔记/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/11/网络、群体与市场笔记/","excerpt":"","text":"图论路径 一个节点序列的集合，序列中任意两个相邻节点间都有一条边相连。 连通图 若一个图中任两点间有路相通，称此图为联通图。 联通分量 1. 子集中任意两个节点间均有路径相连 2. 该自己不是其他任何满足条件1的子集的一部分 小世界现象你和朋友间的路径不仅可延伸至世界相当比例的人群，这些路径实际上都惊人的短。 强联系和弱联系基本的社交网络概念引申的三个问题： 信息如何通过社交网络传播 不同的节点如何在这一进程中发挥独特作用 这些结构性因素怎样印象网络本身的演化 三元闭包在一个社交圈内，若两个人有一个共同的朋友，则这两人在未来成为朋友的可能性就会提高。 聚集系数 节点A的聚集系数定义为A的任意两个朋友彼此也是朋友的概率。 通常，一个节点的聚集系数范围在0和1之间，且该节点附近的的三元闭包过程越强，其聚集系数就倾向于越大 弱联系桥 已知A和B相连，若去掉连接A和B的扁会导致A和B分属不同的联通分量，则该边称为桥。 捷径 若边A-B的端点A和B没有共同的朋友，则称边A-B为捷径。 捷径的跨度 我们定义捷径的跨度为该边两端点在没有该边情况下的实际距离。 捷径与三元闭包在概念上隐含着一种对立：一条边若是捷径，则不可能是三元闭包关系中的任意一边。 强三元闭包性质 若节点A与节点B和C的关系均为强联系，且B和C之间无任何连接（强或弱），则称节点A违反了强三元闭包性质，否则，称节点A满足强三元闭包性质。 捷径与弱联系 社交网络中，若节点A满足强三元闭包性质，并有至少两个强联系边与之相连，则其与其相连的任何捷径均为弱关系。 弱联系与捷径概念的推广邻里重叠度 = （与A、B均为邻居的节点数） / （与A、B中至少一个为邻居的节点数） 闭包、结构洞和社会资本社会网络是用弱联系链接起来的若干紧密群体。 边的嵌入性 定义网络中一条边的嵌入性为其两个端点共同的邻居的数量。 结构洞 网络及其存在的环境同质现象影响社交网络结构最基本的概念之一是同质性，即我们和自己的朋友间往往会有相同的特性。 同质性测试 如果跨性别边所占的比例显著低于2pq，则就有同质现象。 前提：社交网络的节点被二分为两个属性A，B。 p = A / (A + B) q = B / (A + B) 同质现象背后的机制：选择与社会影响一个人的属性当他出生的时候即被选定，且在他/她以后的人生中，建立社会联系发挥一定的作用。 社会化和社会影响： 人们会因为需要和朋友们保持一致而改变自己的行为。 社会影响可以看成是和选择相反的观念：在选择中，个体的特征主导网络连接的形成，但在社会影响过程中，已存在的社会网络连接将会改变人们（可变）的特征。 归属归属网络 用图来表示一群人参与一组社会焦点的情况。 归属网络是所谓的二部图 社会网络与归属网络的协同演化 第一类关系连接是在社会网络中：连接两个个体，表明两者之间的友谊关系。 第二类关系连接是在归属网络中：连接个体和社团活动，表明这个个体参与其中。（我们称此网络是社会归属网络） 正关系与负关系平衡定理 如果一个标记的完全图是平衡的，则要么它的所有节点两两都是朋友，要么它的节点可以被分为两个组X和Y，其中X组内的节点两两都是朋友，Y组内的节点两两也都是朋友，而X组中的每个节点都是Y组中每个节点的敌人。 弱结构平衡性质 任意三个节点，均不存在两个正关系边和一个负关系边的连接模式。 这里所言，三个负关系也是平衡的，只不过是弱平衡 弱平衡网络的特性 如果一个标记的完全图是弱平衡的，则它的节点可分成不同的组，并且满足同一组中任意两个节点互为朋友，不同组之间任意两个节点互为敌人。 博弈纳什均衡 即使不存在占优策略，我们也可以通过参与人彼此策略的最佳应对，来预测参与人的策略选择行为。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://Ison-Laihus.github.io/tags/笔记/"}]},{"title":"浅谈微服务","slug":"浅谈微服务","date":"2018-04-11T09:39:41.000Z","updated":"2018-04-11T14:18:39.502Z","comments":true,"path":"2018/04/11/浅谈微服务/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/11/浅谈微服务/","excerpt":"","text":"服务首先，我们从服务开始说起。 何为服务？在我看来，服务就是一个能够提供一些功能的开放功能体。 之所以说其开放，是由于其能够被供以其他服务进行调用。 通常我们所说的服务，一般都只那些大而却的系统。其层次较深，逻辑复杂，结构混乱，牵一发而动全身，模块间的高内聚、低耦合似乎并不容易做到。 人都喜欢精简轻巧的东西。俗话说，简单即是美，于是微服务就应运而生。 微服务微服务，顾名思义，就是小型的服务。 其就是将产品的功能细分，每个细分之后的模块都单独做成一个服务（即微服务），然后这些服务之间通过网络通信进行协同工作。 将模块微服务化，就形成了一种架构风格——微服务架构。 其网络通信的方式有很多，但通常都是HTTP RESTful API的方式。 但是，在对产品进行功能细分的时候，我们不能盲目的划分到最细。毕竟，服务间的通信也是影响性能的重要指标之一。 尽管微服务架构会有通信的开销，但是它有很多好处，使得人们对其趋之若鹜。 容易被替换和升级 由于项目是若干个微服务的组合，在需要替换或升级的时候，只需要一次针对一个微服务。做好之后，替换掉相应的微服务，相同的接口使其能够完美实现替换。能够使得产品很平滑地过渡而不影响使用。 微服务可选择最适合自己的技术方案 不同服务之间除了功能调用之外没有任何的联系。所以，每个服务都可以选用独立的开发语言和环境，不需要依赖于其他任何服务。这样就很灵活。 能够去中心化管理 自行其是, 自我管理, 不必在局限在一个系统里, 围绕着一个中心。不光是在功能上，在数据管理方面也是一样。各人自扫门前雪, 自己管理和维护自己的数据, 各自之间互不直接访问彼此的数据, 只通过 API 来存取数据。 参考什么是微服务解析微服务架构(一)：什么是微服务解析微服务架构(二)：融入微服务的企业集成架构解析微服务架构(三)：微服务重构应用及IBM解决方案","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://Ison-Laihus.github.io/tags/架构/"}]},{"title":"mysql之char、varchar、text","slug":"mysql之char、varchar、text","date":"2018-04-10T15:09:54.000Z","updated":"2018-04-11T08:35:13.248Z","comments":true,"path":"2018/04/10/mysql之char、varchar、text/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/10/mysql之char、varchar、text/","excerpt":"","text":"在mysql之中，定义了很多数据类型作为存储的字段的类型。 这里只是对char、varchar和text这三个类型进行区别介绍。 char 存储固定长度字符 上限为255字节 char(n)中的n代表字符的个数，而不是字节个数 超过char的n设置，会被截断 速度快 存在空间浪费，无论实际上存储了多少字符，但其所占空间是 n*(字符字节长度)，多余的空间使用空格填充 varchar 存储可变长度字符 上限为65535字节，但实际可以存储的最大长度为65532字节 varchar(n)代表可以存储n个字符，但是其最大的实际存储空间应该是n+1 超过varchar的n设置，会被截断 速度慢 不存在空间浪费，有部分字节被用来记录数据长度，达到可变长的效果。 text 存储可变长度大数据 上限为65535字节，实际存储的最大长度仍为65535字节，其使用的是额外的空间存放数据长度 速度慢 不存在空间浪费，有额外字节被用来记录数据长度，达到可变长的效果。 text不以字符数来表明存储大小，其有几个相关的类型，并规定了最大的存储字节。 Type Maximum length tiny 255 bytes text 65,535 bytes = 64KiB mediumtext 16,777,215 bytes = 16MiB longtext 4,294,967,295 bytes = 4GiB","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://Ison-Laihus.github.io/tags/mysql/"}]},{"title":"PHP PCRE模式正则","slug":"PHP-PCRE模式正则","date":"2018-04-03T13:51:42.000Z","updated":"2018-04-11T09:35:16.726Z","comments":true,"path":"2018/04/03/PHP-PCRE模式正则/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/03/PHP-PCRE模式正则/","excerpt":"","text":"PCRE什么是PCRE，其全名为Perl Compatible Regular Expressions，中文解释为“兼容Perl的正则表达式”。 分隔符当使用PCRE函数的时候，模式需要由分隔符闭合包裹。分隔符可以是任意非字母数字、非反斜线、非空白字符。 经常使用的分隔符是正斜线(/)、has符号(#)、取反符号(~)。 如果分隔符需要在模式内进行匹配，它必须使用反斜线进行转义。 基础语法这里不进行赘述，基础语法可以参见W3School正则表达式教程 模式修饰符 大小写不敏感匹配 1i(PCRE_CLAELESS) “行首”(^)和“行末”($)匹配目标字符串中任何换行符之前或之后 1m(PCRE_MULTILINE) 模式中的点号元字符匹配所有字符，包括换行符 1s(PCRE_DOTALL) 模式中没有经过转义的或不在字符类中的空白数据字符总会被忽略，并且位于一个未转义的字符类外部的#字符和下一个换行符之间的字符也被忽略 1x(PCRE_EXTENDED) 模式被强制为“锚定”模式，也就是说约束匹配使其仅从 目标字符串的开始位置搜索 1A(PCRE_ANCHORED) 模式中的元字符美元符号仅仅匹配目标字符串的末尾。如果这个修饰符 没有设置，当字符串以一个换行符结尾时， 美元符号还会匹配该换行符(但不会匹配之前的任何换行符)。 如果设置了修饰符m，这个修饰符被忽略. 1D(PCRE_DOLLAR_ENDONLY) 当一个模式需要多次使用的时候，为了得到匹配速度的提升，值得花费一些时间 对其进行一些额外的分析。如果设置了这个修饰符，这个额外的分析就会执行。当前， 这种对一个模式的分析仅仅适用于非锚定模式的匹配(即没有单独的固定开始字符)。 1S 这个修饰符逆转了量词的”贪婪”模式。 使量词默认为非贪婪的，通过量词后紧跟? 的方式可以使其成为贪婪的。 1U(PCRE_UNGEEDY) 模式和目标字符串都被认为是 utf-8 的。 1u(PCRE_UTF8) 中文匹配这里，重点讲的是进行中文的匹配。 在其他的一些语言中，使用\\w是可以匹配得上中文字符的。但是在PHP的PCRE模式中，并不能匹配上。 这时，我们就得用到模式修饰符u 基本汉字Unicode编码范围为 4E00-9FA5我们可以这样编写正则模式： 1$pattern = &apos;/[\\x&#123;4E00&#125;-\\x&#123;9FA5&#125;]+/u&apos; 但是这样并不能匹配所有的汉字，所有汉字的Unicode编码范围见详情 由于英文字符所占的Unicode编码范围为 00-FF，若在只有中文和英文字符的情况下，我们可以取巧，使用如下的模式进行匹配： 1$pattern = &apos;/[^\\x&#123;00&#125;-\\x&#123;ff&#125;]+/u&apos;;","categories":[],"tags":[{"name":"PHP Regex","slug":"PHP-Regex","permalink":"http://Ison-Laihus.github.io/tags/PHP-Regex/"}]},{"title":"mysql 常用操作","slug":"mysql-常用操作","date":"2018-04-03T11:26:21.000Z","updated":"2018-04-28T06:54:57.392Z","comments":true,"path":"2018/04/03/mysql-常用操作/","link":"","permalink":"http://Ison-Laihus.github.io/2018/04/03/mysql-常用操作/","excerpt":"","text":"数据的导入导出导入sql文件 source [/path/to/sql/file] 导入纯数据文件 load data local infile &apos;[/path/of/data/file]&apos; into table [tablename] fields terminated by &apos;[seperator]&apos; lines terminated by &apos;[seperator]&apos;; 导出数据 mysqldump -h[hostname] -u[username] -p[password] [databasename] [tablename] &gt; [/path/to/store/sql/file] 建议在输入上述命令，输入密码那个参数中，只需要输入 -p 即可，无须在其后跟上password，而是在输入这行命令之后再由系统指导进行输入，一般Linux不允许上述命令，因为密码以明文输出不安全 导出一部分数据 SELECT ... INTO OUTFILE &apos;[file/path]&apos;; 列操作修改列名 alter table [tablenamme] change column [columnNameBeforeChange] [columnNameAfterChange] char(40) 添加列名 alter table [tablename] add column [columnName] varchar(40); 删除列名 alter table [tablenam]e drop column [columnName]; 修改列类型 alter table [tablename] modify [columnName] char(40); 或 alter table [tablename] change [columnNameBeforeChange] [columnNameBeforeChange] char(40); 编码数据库查看数据库编码 show create database [db_name]; 修改数据库编码 alter database [db_name] default character set [character_name]; 数据表查看数据表编码 show create table [table_name]; 修改数据表编码 alter table [table_name] default character set [character_name]; 数据表列字段查看数据表列字段编码 show full columns from [table_name]; 修改数据表列字段编码 alter table [table_name] change [column_name_before] [column_name_after] [column_type] character set [character_name]; 或 alter table [table_name] modify [column_name] [column_type] charset set [character_name]; 查看mysql数据库所有的编码show variables like &apos;%char%&apos;; 查看mysql数据库所有排序规则show variables like &apos;%collation_%&apos;; 通配符12_ : 匹配任何单个字符% : 匹配0或任意多个字符 这两个通配符需要使用 LIKE 或 NOT LIKE 不能使用 = 或 != 扩展正则表达式123456. : 匹配单个字符* : 匹配0个或任意多个字符^ : 开头$ : 结尾[] : 某一个（括号中的字符）&#123;n&#125; : 重复n次 使用 REGEXP 或 NOT REGEXP","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Ison-Laihus.github.io/tags/Mysql/"}]},{"title":"制作Makefile","slug":"制作Makefile","date":"2018-03-31T09:06:56.000Z","updated":"2018-04-13T15:55:01.446Z","comments":true,"path":"2018/03/31/制作Makefile/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/31/制作Makefile/","excerpt":"","text":"什么是MakefileMakefile文件，是供给make（一个工具程序）进行自动化构建的规则文件。 make，是一种转换文件形式的的工具，转换的目标称为“target”，与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。 它使用“Makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。 大多数情况下，它被用来编译源代码，生成结果代码， 然后把结果代码连接起来生成可执行文件或者库文件。 Makefile文件的格式12&lt;target&gt; : &lt;prerequisites&gt; &lt;commands&gt; 上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。 “目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。 每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。 目标（target）目标可以是文件名，也可以是操作名。 当其为文件名时，指的是Make命令所要构建的对象。其也可以是多个文件名。 当其为操作名时，被称为“伪目标”（phony target）。但是，如果当前目录有和伪目标重名的文件时，操作不会被执行。他会将操作名看成是目标文件名。为避免这种情况，可以明确声明操作时“伪目标”。 .PHONY: clean clean: rm *.o temp 明确声明了clean是“伪目标”。 若Make运行时不指明目标，则默认执行规则构建文件中的第一个目标。 前置条件（prerequisite）前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。 命令（commands）命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。 每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量 .RECIPEPREFIX 声明。 .RECIPEPREFIX = &gt; clean: &gt; rm *.o temp 每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。也就是说，一行shell命令不能使用其他行shell命令的变量和结果。 要使得他们在一个shell进程中执行，有三种方法： 所有shell命令写在一行 clean: export end=finish; echo $end 行尾使用反斜杠 clean: export end=finish; \\ echo $end 我们可以使用.ONESHELL命令来标志一个target中的所有shell命令都在一个shell进程中执行。 .ONESHELL clean: export end=finish echo $end Makefile文件语法注释#号开头代表注释一行。 回声（echoing）正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。 在命令的前面加上@，就可以关闭回声 通配符（wildcard）用来指定一组符合条件的文件名。与Bash的通配符一致 模式匹配%.o: %.c 等同于 f1.o: f1.c f2.o: f2.c 使用匹配符%，可以将大量同类型的文件，只用一条规则就能完成构建。 变量和赋值符 变量可以随意定义，但是定义时需要有初始值 变量的使用，必须使用 $() 符进行变量的调用 txt=Hello test: @echo $(txt) 调用shell变量时，需要在shell变量前再加上一个 $ 符 赋值符分为四类： =：在执行时扩展，允许递归扩展 :=：在定义时扩展 ?=：只有在该变量为空时才设置值 +=：将值追加到变量的尾端 内置变量1234567AR: 归档程序，默认为&apos;ar&apos;CC: C语言代码编译程序，默认为&apos;cc&apos;CXX: C++代码编译程序，默认为&apos;g++&apos;CPP: 运行C代码预处理的程序，从标准输出输出结果，默认为&apos;$(CC) -E&apos;CFLAGS: 给C编译器的额外标志CXXFLAGS: 给C++编译器的额外标志... 内置变量在shell命令中使用时，需要使用 $() 进行调用 自动变量1. $@指代当前目标，就是Make命令当前构建的目标。 2. $&lt;指代第一个前置条件。 3. $?指代比目标更新的所有前置条件，之间以空格分隔。 4. $^指代所有前置条件，之间以空格分隔。 5. $*指代匹配符%匹配的部分。 6. $(@D) &amp; $(@F)分别指向$@的目录名和文件名。 7. $(&lt;D) &amp; $(&lt;F)分别指向$&lt;的目录名和文件名。 判断和循环Makefile使用Bash语法，完成判断和循环。 Bash语法，见此教程 函数$(function arguments) 或 $(function arguments) Makefile提供了很多内置的函数，可供调用，如下： shell函数 用来执行shell命令 srcfiles := $(shell echo src/{00..99}.txt) wildcard函数 用来在Makfile中替换Bash通配符 srcfiles := $(wildcard src/*.txt) subst函数 用来文本替换 $(subst from,to,text) 例如 $(substr ee,EE,feet on the street) # 将feet on the street 替换成 fEEt on the street patsubst函数 用于模式匹配的替换 $(patsubst pattern,replacement,text) 替换后缀名 写法： 变量名 + 冒号 + 后缀名替换规则。 其实际上是patsubst函数的一种简写。 min: $(OUTPUT:.js=.min.js) # 将变量OUTPUT的后缀名 `.js` 全部替换成 `.min.js` 参考阮一峰的Make命令教程GUN make官方教程Makefile文件教程","categories":[],"tags":[{"name":"Linux make makefile","slug":"Linux-make-makefile","permalink":"http://Ison-Laihus.github.io/tags/Linux-make-makefile/"}]},{"title":"Linux下设置输出字符的颜色","slug":"Linux下设置输出字符的颜色","date":"2018-03-27T07:10:35.000Z","updated":"2018-03-27T07:57:44.551Z","comments":true,"path":"2018/03/27/Linux下设置输出字符的颜色/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/27/Linux下设置输出字符的颜色/","excerpt":"","text":"语法\\033[显示方式;前景色;背景色;m输出字符串\\033[0m 或 \\e[显示方式;前景色;背景色;m输出字符串\\e[0m \\033[ 或 \\e[ 引导转义序列，m 表示设置属性并结束转义序列，\\033[0m 或 \\e[0m 用于恢复默认的终端输出属性。 转义序列转义序列以控制字符ESC开头，该字符的ASCII码十进制为27，十六进制为0x1B，八进制表示为033。由于转义序列多数超过两个字符，所以通常以 ESC 和左括号 [ 开头，该起始序列（\\033[ 和 \\e[）称为控制序列引导符。 显示方式 &amp; 前景色 &amp; 背景色这三个属性是用来设置输出字符串的三个属性。 这三个属性并没有顺序的限制，因为表示他们的值范围不同 颜色 0 - 黑 1 - 红 2 - 绿 3 - 黄 4 - 蓝 5 - 洋红 6 - 青 7 - 白 字体颜色范围 30-37背景颜色返回 40-47 显示 0 - 默认 1 - 粗体/高亮 22 - 非粗体 4 - 单条下划线 24 - 无下划线 5 - 闪烁 25 - 无闪烁 7 - 反显、翻转前景色和背景色 Linux终端下的测试在Linux的终端下，我们可以使用如下命令来输出彩色字或彩色背景 echo -e &quot;\\033[显示方式;前景色;背景色;m输出字符串\\033[0m&quot; 双引号是必须的，因为其实bash分辨词素的标记 参考https://www.cnblogs.com/clover-toeic/p/4031618.htmlhttps://blog.csdn.net/exlsunshine/article/details/28440889https://blog.csdn.net/hejinjing_tom_com/article/details/12162491","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://Ison-Laihus.github.io/tags/Linux/"}]},{"title":"C++开发web服务（库：xmlrpc-c）","slug":"C-开发web服务（库：xmlrpc-c）","date":"2018-03-26T15:48:30.000Z","updated":"2018-03-26T16:27:12.633Z","comments":true,"path":"2018/03/26/C-开发web服务（库：xmlrpc-c）/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/26/C-开发web服务（库：xmlrpc-c）/","excerpt":"","text":"开发环境Ubuntu16.04gcc 5.4.0xmlrpc-c 1.39.12 xmlrpc-c介绍xmlrpc-c是一个对XML-RPC协议的一个C/C++的实现。其包含了很多必须的库，在编译服务端和客户端的时候都需要使用其进行链接编译。 下载地址 | 文档 编译安装xmlrpc-c下载xmlrpc-c压缩文件之后，解压，进入其目录下，使用如下命令进行安装： ./configure make sudo make install 编译链接客户端和服务端这里，我们只介绍最简单的服务模式（即源文件examples/cpp中的xmlrpc_sample_add_server 和 xmlrpc_sample_add_client所示例的模式）。 在源文件examples/cpp文件夹下，xmlrpc-c的开发者已经为我们写好了Makefile文件，我们只需要执行make命令即可将cpp目录下的所有文件都编译完成。 但是，其Makefile文件很晦涩难懂，在我们开发服务的时候，如何编译代码文件呢？ 客户端客户端的编译需要链接如下的库： xmlrpc_client++ xmlrpc++ xmlrpc_util++ 所以，我们编译客户端的命令如下： g++ 源文件 -o 可执行文件 -lxmlrpc_client++ -lxmlrpc++ -lxmlrpc_util++ 服务端服务端的编译需要链接如下的库： xmlrpc_server++ xmlrpc++ xmlrpc_server_abyss++ xmlrpc_util++ 所以，我们编译服务端的命令如下： g++ 源文件 -o 可执行文件 -lxmlrpc_server++ -lxmlrpc++ -lxmlrpc_server_abyss++ -lxmlrpc_util++ 知晓了这些，我们就可以将examples/cpp目录下的示例文件xmlrpc_sample_add_server.cpp 和 xmlrpc_sample_add_client.cpp 拷贝出来单独编译。 客户端调用服务端的参数模型调用示例： string const serverUrl(&quot;http://localhost:8080/RPC2&quot;); string const methodName(&quot;sample.add&quot;); xmlrpc_c::clientSimple myClient; xmlrpc_c::value result; myClient.call(serverUrl, methodName, &quot;ii&quot;, &amp;result, 5, 7); 那么就让我来介绍一下myClient.call中的第三个参数 &quot;ii&quot; 代表的含义。 在xmlrpc-c中定义了很多类型： xmlrpc_c::value_boolean xmlrpc_c::value_int xmlrpc_c::value_boolean xmlrpc_c::value_boolean xmlrpc_c::value_boolean xmlrpc_c::value_boolean xmlrpc_c::value_boolean xmlrpc_c::value_boolean 在客户端调用服务端的时候，myClient.call中的第三个参数代表着formatChar，即对应的输入类型符，其与上述的类型的映射关系如下： i xmlrpc_c::value_int b xmlrpc_c::value_boolean d xmlrpc_c::value_double s xmlrpc_c::value_string w xmlrpc_c::value_boolean t xmlrpc_c::value_boolean 8 xmlrpc_c::value_boolean 6 xmlrpc_c::value_boolean n xmlrpc_c::value_boolean I xmlrpc_c::value_boolean p xmlrpc_c::value_boolean A xmlrpc_c::value_boolean S xmlrpc_c::value_boolean V xmlrpc_c::value_boolean b xmlrpc_c::value_boolean xmlrpc_build.c文件中","categories":[],"tags":[{"name":"C++ Linux xmlrpc-c","slug":"C-Linux-xmlrpc-c","permalink":"http://Ison-Laihus.github.io/tags/C-Linux-xmlrpc-c/"}]},{"title":"Linux 下安装libmysqlclient-dev找不到链接库","slug":"Linux-下安装libmysqlclient-dev找不到链接库","date":"2018-03-26T10:19:59.000Z","updated":"2018-03-26T14:04:57.704Z","comments":true,"path":"2018/03/26/Linux-下安装libmysqlclient-dev找不到链接库/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/26/Linux-下安装libmysqlclient-dev找不到链接库/","excerpt":"","text":"前言想用C++在Linux环境下操作MySQL数据库。 环境Ubuntu16.04MySQL5.7gcc 5.4.0 环境搭建安装mysql sudo apt-get install mysql-server mysql-client 安装libmysqlclient-dev sudo apt-get install libmysqlclient-dev libmysqlclient-dev这个库中有着操作mysql数据库的一些头文件和链接库 问题在 /usr/include 中可以找到mysql文件夹，其中有一些操作mysql的头文件但是在 /usr/lib 中找不到链接库 libmysqlclient.so 原因在安装 libmysqlclient-dev 的时候，将 libmysqlclient.so 链接库文件放置在了 /usr/lib/x86_64-linux-gnu 这个文件夹中。 解决办法在 /usr/lib 中增加 libmysqlclient.so 的链接： ln -s /usr/lib/x86_64-linux-gnu/libmysqlclient.so /usr/lib/libmysqlclient.so 这样一来，问题就解决了","categories":[],"tags":[{"name":"Linux MySQL C++","slug":"Linux-MySQL-C","permalink":"http://Ison-Laihus.github.io/tags/Linux-MySQL-C/"}]},{"title":"Linux 下建立链接","slug":"Linux-下建立链接","date":"2018-03-26T09:54:56.000Z","updated":"2018-03-26T10:19:01.798Z","comments":true,"path":"2018/03/26/Linux-下建立链接/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/26/Linux-下建立链接/","excerpt":"","text":"链接，在Linux文件系统中，可以视其为档案的别名。 链接的分类 硬链接 以文件的副本的形式存在，但不占用实际空间 不允许给目录创建硬链接 只有在同一个文件系统中才能创建 软链接 以路径的形式存在，类似于Windows操作系统中的快捷方式 可以跨文件系统 可以对一个不存在的文件名进行链接 可以对目录进行链接 创建链接的命令命令格式 ln [参数] [源文件或目录] [目标文件或目录] 命令参数必要参数 -b 删除，覆盖以前建立的链接 -d 允许超级用户制作目录的硬链接 -f 强制执行 -i 交互模式，文件存在则提示用户是否覆盖 -n 把符号链接视为一般目录 -s 软链接（符号链接） -v 显示详细的处理过程 选择参数 -S &quot;-S&lt;字尾备份字符串&gt;&quot; 或 &quot;--suffix=&lt;字尾备份字符串&gt;&quot; -V &quot;-V&lt;备份方式&gt;&quot; 或 &quot;--version-control=&lt;备份方式&gt;&quot; --version 显示版本信息 特点 ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其他文件都会发生相同的变化 软链接只会在选定的位置上生成一个文件的镜像，不会占用磁盘空间 硬链接会在选定的位置上生成一个和源文件相同大小的文件 无论是硬链接还是软链接，文件都保持同步变化 ln指令用在链接文件或目录，如果同时指定两个以上的文件或目录，则最后的目的地是一个已存在的目录（把前面指定的所有文件或目录复制到该目录中），否则会报错","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://Ison-Laihus.github.io/tags/Linux/"}]},{"title":"Ubuntu 下找不到动态链接库的原因","slug":"Ubuntu-下找不到动态链接库的原因","date":"2018-03-22T09:44:31.000Z","updated":"2018-03-22T10:02:00.435Z","comments":true,"path":"2018/03/22/Ubuntu-下找不到动态链接库的原因/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/22/Ubuntu-下找不到动态链接库的原因/","excerpt":"","text":"情况描述Linux下编程，下载所需要的安装包，解压，然后编译安装，通常命令： ./configure make sudo make install # 需要创建文件 当我们编译安装之后，到 /usr/local/lib 里和 /usr/local/include 里分别查看安装的库文件和头文件，然后我们欣喜的看到我们所安装的文件已经被放入到这里两个文件中，于是我们就去欣喜的写代码去了 ... coding ... 当我们的代码写好了之后，编译链接，然后运行，发下，它竟然提示: 找不到shared libraries ?!! 然后我们又反复的去 /usr/local/lib 中去查找，发现的确已经存在了。 于是我们思考是否是 /usr/local/lib 没有加入到 共享链接库的配置文件中。 于是我们打开 /etc/ld.so.conf 进行查看，发现： include /etc/ld.so.conf.d/*.conf /usr/local/lib 已经将 /usr/local/lib 包含进去了 解决办法执行下列命令 sudo ldconfig 重新加载一下所有的共享库文件，因为我们在安装好所需要的包之后，并没有给系统足够的时间来反应你所添加的内容，所以我们需要告诉系统应该重新加载一下。 之后再运行代码，OK了","categories":[],"tags":[{"name":"Linux  Ubuntu  C++","slug":"Linux-Ubuntu-C","permalink":"http://Ison-Laihus.github.io/tags/Linux-Ubuntu-C/"}]},{"title":"gcc 命令详解","slug":"gcc-命令详解","date":"2018-03-22T07:27:33.000Z","updated":"2018-04-09T15:23:51.737Z","comments":true,"path":"2018/03/22/gcc-命令详解/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/22/gcc-命令详解/","excerpt":"","text":"C/C++编译过程 编译预处理 编译、优化 汇编 链接 编译预处理对宏定义指令、条件编译指令、头文件包含指令、特殊符号、预处理模块进行处理。 宏定义指令： #define Name TokenString #undef ... 条件编译指令： #ifdef #ifndef #else #elif #endif ... 头文件包含指令： #include &quot;FileName&quot; // 开发者自己编写的头文件 #include &lt;FileName&gt; // 系统提供的头文件 预处理模块： #progma // 设定编译器的窗台或是只是编译器完成一些特定的动作 编译、优化解释代码，生成汇编程序。 汇编过程把汇编语言代码翻译成目标机器指令。 链接由汇编程序生成的目标文件并不能立即被执行，其中可能还有许多没有解决的问题。归纳起来，就是调用了其他文件中的内容。这需要经过链接才能解决。 链接的主要工作就是讲有关的目标文件彼此相连，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。 静态连接在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。 动态连接在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。 常用编译命令1. 选项 -E （预处理）将带#的语句重新展开至指定文件中，比如 #define, #include &quot;*.h&quot; gcc -E test.c -o test.i 将test.c预处理输出test.i文件。 2. 选项 -S （编译）（比前一步多了编译这一步）将.c文件编译成汇编文件（.s文件） gcc -S test.c -o test.s 3. 选项 -c （汇编）（比前一步多了assemble这一步）将.c文件编译成汇编文件（.o文件） gcc -c test.c -o test.o 4. 无选项编译链接（比前一步多了链接这一步）gcc test.c 将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。 5. 无选项链接gcc test.o -o test 将编译输出文件test.o链接成最终可执行文件test。 6. 选项-Ogcc -O1 test.c -o test 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。 7. 选项-std指定使用哪个C/C++语言标准编译 // 使用 C++11 g++ -std=c++11 8. 选项-I指定使用的头文件的目录，默认为 /usr/include 和 /usr/local/include，这两个目录是GCC默认的头文件寻找目录。 gcc -I . test.c -o test 当在预处理test.c的时候，遇到引用头文件，会在当前目录下进行寻找 9. 选项-L指定链接库的目录，默认为 /usr/lib 和 /usr/local/lib。 gcc -L . test.c -o test -lpthread 在当前目录下寻找pthread的链接库文件进行链接。 10. 选项-l指定某个链接库进行链接。 gcc test.c -o test -lpthread 将test.c的二进制文件与pthread链接库进行链接生成可执行文件。 多源文件的编译方法1. 多个文件一起编译gcc testfun.c test.c -o test 将testfun.c 和 test.c 分别变异后连接成test可执行文件 2. 分别编译各个源文件，之后对编译后输出的目标文件链接gcc -c testfun.c gcc -c test.c gcc testfunc.o test.o -o test 参考gcc编译命令","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://Ison-Laihus.github.io/tags/C/"}]},{"title":"了解CMake","slug":"了解cmake","date":"2018-03-21T08:18:36.000Z","updated":"2018-03-21T12:05:39.558Z","comments":true,"path":"2018/03/21/了解cmake/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/21/了解cmake/","excerpt":"","text":"什么是CMakeCMake允许开发者编写一种平台无关的CMakeList.txt文件来定制整个编译流程，然后在根据目标用户的平台进一步生成所需的本地化Makefile和工程文件。 其特点是： Write once, run everywhere. 使用CMake生成Makefile并编译的流程 编写CMake配置文件CMakeLists.txt 执行命令 cmake PATH 或者 ccmake PATH 生成 Makefile，其中 PATH 是CMakeLists.txt所在的目录。 使用make命令进行编译 ccmake 和 cmake 的区别在于前者提供了一个交互式的界面 CMakeLists.txt语法其由命令、注释和空格组成，其中命令是不区分大小写的。注释由 # 开头。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。 CMakeLists.txt常见命令一层目录cmake_minimum_required(VERSION 2.8) 指定运行此配置文件所需的CMake的最低版本为2.8一般项目的主CMakeLists.txt文件中一定有这个命令，子目录里不需要。 project(TEST) 表示项目的名称为TEST，主目录中的CMakeLists.txt文件中必须有，子目录中的CMakeLists.txt文件中不需要。 add_executable(Test main.cc) 将名为main.cc的源文件编译成一个名称为Test的可执行文件。如果需要将多个源文件编译成一个可执行文件，则添加到main.cc 的后面。更简便的方法如下： aux_source_direct(. DIR_SRCS) 查找 . 目录下（也就是当前目录下）的所有源文件，并将名称保存到DIR_SRCS变量中。编译时就可如下： add_executable(Test ${DIR_SRCS}) 多层目录add_subdirectory(sub) 当一个项目中有多层目录时，需要在上层CMakeLists.txt文件中添加子目录，并且子目录下也应当有CMakeLists.txt文件。这样一来，子目录下的CMakeLists.txt文件和源代码也会被处理。 aux_source_directory(. DIR_LIB_SRCS) add_library(MathFunctions ${DIR_LIB_SRCS}) 上面是子目录中CMakeLists.txt文件中的内容，其将子目录下的所有源文件编译为静态链接库。 set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions) target_link_libraries(Test ${EXTRA_LIBS}) 链接，当有子目录的时候，且子目录的代码是可执行文件的一部分而未被分离成另一个可执行文件，则需要链接它。 自定义编译选项Cmake允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。 cinfigure_file( &quot;${PROJECT_SOURCE_DIR}/config.h.in&quot; &quot;${PROJECT_BINARY_DIR}/config.h&quot; ) 该命令用于加入一个配置头文件config.h，这个文件有CMake从config.h.in生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。 config.h.in文件中的内容如下： #cmakedefine USE_MYMATH 其定义了变量USE_MYMATH，以供CMakeLists.txt文件使用。 option (USE_MYMATH &quot;Use provded math implementation&quot; ON) option命令添加了一个USE_MYMATH选项，并且设置了默认值为ON，中间的参数是对USE_MYMATH参数的描述。 设置为ON，则生成的config.h文件中就会定义出在config.h.in中配置的变量；设置为OFF，则生成的config.h文件中的定义就会被注释掉。 安装和测试CMake可以指定安装规则，以及添加测试。这两个功能分别可以通过产生Makefile后使用 make install 和 make test 来执行。 定制安装规则在子目录下的CMakeLists.txt文件中添加如下两行 install (TARGETS MathFunctions DESTINATION bin) install (FILES MathFunctions.h DESTINATION include) 在项目根目录下的CMakeLists.txt文件总添加如下两行 install (TARGETS Test DESTINATION bin) install (FILES &quot;${PROJECT_BINARY_DIR}/config.h&quot; DESTINATION include) 通过上面的定制，生成Test文件和MathFunctions函数库libMathFunctions.o文件将会被复制到 /usr/local/bin 中，而 MathFunctions.h和生成的config.h文件则会被复制到 /usr/local/include 中。 为工程添加测试CMake提供了一个称谓CTest的测试工具。我们只要在项目的根目录的CMakeLists.txt文件总调用一系列的 add_test 命令。 enable_testing() # 启用测试 在CMakeLists.txt文件的开头，需要添加这一行。 语法： add_test(TEST_NAME executable_file params) # 示例 add_test(test_run test 5, 2) add_test语法有两个以上的参数，第一个是自定义的测试命名，第二个是可执行文件名，其他的为可执行文件需要传入的参数。 set_tests_properties(自定义的测试名 PROPERTIES PASS_REGULAR_EXPRESSION 被包含的字符串) 这个语句是为了检测定义的测试的返回值中是否包含所给的字符串，PASS_REGULAR_EXPRESSION用来测试输出是否所给的字符串。 简化测试用例——宏定义 macro(do_test arg1 arg2 result) add_test (test_${arg1}_${arg2} Test ${arg1} ${arg2}) set_tests_properties(test_${arg1}_${arg2} PROPERTIES PASS_REGULAR_EXPRESSION ${result}) endmacro(do_test) do_test(5 2 &quot;is 25&quot;) do_test(5 2 &quot;is 25&quot;) do_test(5 2 &quot;is 25&quot;) do_test(5 2 &quot;is 25&quot;) 参考CMake入门实战在linux下使用CMake构建应用程序CMake简要教程","categories":[],"tags":[{"name":"工具 C++ cmake","slug":"工具-C-cmake","permalink":"http://Ison-Laihus.github.io/tags/工具-C-cmake/"}]},{"title":"Ubuntu16.04 + nginx + C++ + spawn-fcgi 开发web程序","slug":"Ubuntu16-04-nginx-C-spawn-fcgi-开发web程序","date":"2018-03-20T12:49:02.000Z","updated":"2018-03-20T15:23:34.280Z","comments":true,"path":"2018/03/20/Ubuntu16-04-nginx-C-spawn-fcgi-开发web程序/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/20/Ubuntu16-04-nginx-C-spawn-fcgi-开发web程序/","excerpt":"","text":"环境搭建系统：Ubuntu16.04nginx：1.13.9spawn-fcgi：1.6.4gcc：5.6 安装nginxnginx下载 解压后，进入nginx目录下，进行安装： ./configure 但是，在安装过程，可能会缺少一些安装包，例如pcre，zlib，OpenSSL，直接进行apt-get install 安装即可。 install make sudo make install # 注意需要root权限，因为需要创建文件 安装完成后，nginx放置在/usr/local/nginx目录下，主要的配置文件是其下的conf中的nginx.conf 安装spawn-fcgispawn-fcgi下载 解压后，进入spawn-fcgi目录 ./configure make 生成可执行文件之后，将其移动到nginx的sbin目录下 cp src/spaw-fcgi /usr/local/nginx/sbin 安装fcgi库fcgi库下载需要修改 /include/fcgio.h，添加如下代码 #include &lt;cstdio&gt; 然后，进行安装 ./configure make sudo make install # 注意需要root权限，因为需要创建文件 nginx命令启动服务 /usr/local/nginx/sbin/nginx start 关闭服务 spawn-fcgi命令","categories":[],"tags":[]},{"title":"Linux cURL命令记录","slug":"Linux-cURL命令记录","date":"2018-03-20T12:07:06.000Z","updated":"2018-03-20T12:34:27.116Z","comments":true,"path":"2018/03/20/Linux-cURL命令记录/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/20/Linux-cURL命令记录/","excerpt":"","text":"什么是cURLcURL，是linux中一个利用URL规则在命令行下工作的文件传输工具，是一款很强大的http命令行工具。语法 curl [option] [url] 常见参数 -A/--user-agent &lt;string&gt; 设置用户代理发送给服务器 -b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置 -c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到这个文件中 -C/--continue-at &lt;offset&gt; 断点续转 -D/--dump-header &lt;file&gt; 把header信息写入到该文件中 -e/--referer 来源网址 -f/--fail 链接失败时不显示http错误 -o/--output 把输出写到该文件中 -O/--remote-name 把输出写到该文件中，保留远程文件的文件名 -r/--range &lt;range&gt; 检索来自HTTP/1.1或FTP服务器字节范围 -s/--slient 静音模式，不输出任何东西 -T/--upload-file &lt;file&gt; 上传文件 -u/--user &lt;user[:password]&gt; 设置服务器的用户和秘密 -w/--write-out [format] 什么输出完成后 -x/--proxy &lt;host[:port]&gt; 在给定的端口上使用HTTP代理 -#/--progress-bar 进度条显示当前的传送状态","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://Ison-Laihus.github.io/tags/Linux/"}]},{"title":"浅谈CGI","slug":"浅谈CGI","date":"2018-03-20T11:40:46.000Z","updated":"2018-03-20T11:57:37.564Z","comments":true,"path":"2018/03/20/浅谈CGI/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/20/浅谈CGI/","excerpt":"","text":"文章参考：CGI,FastCGI,php-fpm之间的关系深入理解FastCGI协议","categories":[],"tags":[{"name":"网络 C++","slug":"网络-C","permalink":"http://Ison-Laihus.github.io/tags/网络-C/"}]},{"title":"JavaScript 继承","slug":"JavaScript-继承","date":"2018-03-19T14:08:10.000Z","updated":"2018-03-19T14:53:54.463Z","comments":true,"path":"2018/03/19/JavaScript-继承/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/19/JavaScript-继承/","excerpt":"","text":"许多OO语言都支持两种继承方式： 接口继承：只继承方法签名 实现继承：继承实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现继承主要依靠原型链来实现的。 function SuperType() { this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; this.property = true; } function SubType() { this.subProperty = true; } // 继承 SubType.prototype = new SuperType(); var instance = new SubType(); 两个问题： 包含引用类型值的原型，会被所有实例共享 在创建子类型的实例时，不能向超类型的构造函数中传递参数 借用构造函数原理：函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在新创建的对象上执行构造函数。 function SuperType() { this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } function SubType() { SuperType.call(this); } var instance = new SubType(); instance.colors.push(&quot;black&quot;); console.log(instance.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;] 传递参数相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。 问题方法都在构造函数中定义，因此函数复用就无从谈起了。在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都智能使用构造函数模式。 组合继承有时也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承。 function SuperType(name) { this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } SuperType.prototype.sayName = function() { console.log(this.name); } function SubType(name, age) { SuperType.call(this, name); // 第二次调用 SuperType() this.age = age; } SubType.prototype = new SuperType(); // 第一次调用 SuperType() SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() { console.log(this.age); } 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中做常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。 原型式继承借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。 function object(o) { function F(){} F.prototype = o; return new F(); } var person = { colors: [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;] }; // obj继承person对象 var obj = object(person); Object.create(fatherObj[, propertiesObj])ECMAScript5通过新增Object.create()方法规范化了原型继承。fatherObj: 要继承的父类对象propertiesObj: 和Object.defineProperties()中第二个参数一样，会覆盖原有同名属性。可选 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再想真的是它做了所有工作一样返回对象。 function createAnother(original) { var clone = object(original); clone.sayHi = function() { console.log(&quot;HI&quot;); } return clone; } 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。 前面的object()函数不是必须的，任何能够返回新对象的函数都适用于此模式。 使用寄生式继承来为对象添加函数，会由于不能做到函数服用而降低效率。这一点与构造函数模式类似 寄生组合式继承由于组合继承存在一个很大的缺陷： 其会调用两次超类型构造函数，一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 因为子类型最终会包含超类型对象的全部实例属性，所以我们不得不在调用子类型构造函数时重写这些属性。 解决办法：寄生组合式继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 背后的思路：不必为了指定子类型的原型而调用超类型的构造函数，我们需要的无非就是超类型原型的一个副本而已。 本质：使用寄生式继承来继承超类型的原型，然后在将结果指定给子类型的原型。 function inheritPrototype(subType, superType) { var prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象 } 这个例子能够保持原型链不变，还避免了在SubType.prototype上面创建不必要的、多余的属性。 这被普遍认为是引用类型最理想的继承范式。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://Ison-Laihus.github.io/tags/JavaScript/"}]},{"title":"'JavaScript严格模式'","slug":"JavaScript严格模式","date":"2018-03-18T07:54:43.000Z","updated":"2018-03-18T08:43:10.244Z","comments":true,"path":"2018/03/18/JavaScript严格模式/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/18/JavaScript严格模式/","excerpt":"","text":"ECMAScript5最早引入了“严格模式”（strict mode）的概念。通过严格模式，可以在函数内部选择进行较为严格的全局或局部的错误条件检测。 使用严格模式的好处：可以提早知道代码中存在的错误，即使捕获一些可能导致编程错误的ECMAScript行为。 选择使用选择进入严格模式，需使用严格模式的编译指示： &quot;use strict&quot;; 其其实是一个为负值的字符串字面量，支持严格模式的引擎会启动严格模式，不支持的就会忽略。 变量严格模式下，什么时候创建变量以及怎么创建变量都是有限制的。 不允许意外创建全局变量message = &quot;Hello&quot;; 这行代码在严格模式下是错误的。在严格模式下，如果给一个没有声明的变量复制，那代码在执行时就会抛出ReferenceError 不能对变量调用delete操作符var clolor = &quot;red&quot;; delete color; 在严格模式下上述代码会出错。虽在非严格模式下允许这样做，但是会静默失败（返回false） 严格模式下对变量有限制不能使用implements, interface, let, package, private, protected, public, static, yield作为变量名，这些都是保留字，将来的ECMAScript版本中可能会用到它们。 对象在严格模式下操作对象比在非严格模式下更容易导致错误。一般来说，在非严格模式下回静默失败的情形，在严格模式下回抛出错误。 在下列情形下操作对象的属性会导致错误： 为只读属性赋值——抛出TypeError 对不可配置的属性使用delete操作符——抛出TypeError 对不可扩展的对象添加属性——抛出TypeError 使用对象字面量时，属性名必须唯一var person = { name: &quot;xiaoming&quot;, name: &quot;honghong&quot; } 严格模式下报错，非严格模式下取第二个。 函数严格模式下的函数命名必须唯一。不能出现两个命名一样的函数，JavaScript中没有像C++中的函数重载。 严格模式下，arguments对象的行为也有所不同 非严格模式：arguments对象和命名参数双向绑定，改动任何一个，另一个的值也会随之改变 严格模式：arguments对象和命名参数无双向绑定 淘汰了arguments.callee 和 arguments.caller在非严格模式下，这两个属性一个引用函数本身，一个引用调用函数。在严格模式下，访问哪个属性都会抛出TypeError。 函数名不能使用保留字只能在脚本的顶级和在函数内部声明函数if (true) { function doSomething() { // ... } } 严格模式下，会导致语法错误。 eval()严格模式下，eval()在包含上下文中不再创建变量和函数。 function doSomething() { eval(&quot;var x = 10&quot;); alert(x); } 上述代码在严格模式下会抛出ReferenceError，因为x未被定义。 可以在eval()中声明变量和函数，但这些变量或函数只能被求值的特殊作用域中有效，随后就会被销毁。 &quot;use strict&quot;; var result = eval(&quot;var x=10, y = 11; x+y&quot;); console.log(result); // 21 上述代码是有效的。 eval和arguments严格模式已经明确禁止使用eval和arguments作为标识符，也不允许读写它们的值。而在非严格模式下是可以重写eval，也可以给arguments赋值。 抑制this在非严格模式下使用函数的apply()和call()方法时，null或undefined值会被转换为全局对象。 而在严格模式下，函数的this值始终是指定的值，无论指定的是什么值。 var color = &quot;red&quot;; function displayColor() { console.log(this.color); } displayColor.call(null); 非严格模式下输出red，this是全局对象严格模式下报错，this是null，对null操作报错 其他 抛弃了with语句——使用会导致语法错误 去掉了JavaScript中的八进制字面量","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://Ison-Laihus.github.io/tags/javascript/"}]},{"title":"人工智能笔记之人工智能概念","slug":"人工智能笔记之人工智能概念","date":"2018-01-02T12:04:33.000Z","updated":"2018-03-18T08:00:18.114Z","comments":true,"path":"2018/01/02/人工智能笔记之人工智能概念/","link":"","permalink":"http://Ison-Laihus.github.io/2018/01/02/人工智能笔记之人工智能概念/","excerpt":"","text":"人工智能分类| 像人一样思考 | 合理地（理性）思考 || 像人一样行动 | 合理地（理性）行动 | 像人一样行动：图灵测试自然语言处理，知识表示，自动推理，机器学习，计算机视觉，机器人学 像人一样思考：认知建模神经生理学实验，心理学实验，认知模型 理性地思考：思维法则逻辑学 理性地行动：理性智能体 理性行动：做正确的事 正确的事：在当前已有知识和前提条件下，能获得最佳期望结果的决定或行动 智能体是能感知和行动的实体 理性智能体智能体：指任何能通过传感器感知环境和通过执行器作用于环境的实体 理性智能体：对于每种可能的感知系列，理性智能体应该选择一个这样的动作来执行，此动作能在它所具有执行和感知序列提供的证据条件下，使得它的性能度量期望最大化。 理性有别于无所不知 智能体的设计在设计智能体时须首先明确的四大要素，简称PEAS 性能度量（Performance measure） 环境（Environment） 执行器（Actuators） 传感器（Sensors）","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://Ison-Laihus.github.io/tags/AI/"}]},{"title":"jQuery插件Datatables的使用","slug":"jQuery插件Datatables的使用","date":"2017-12-19T06:51:58.000Z","updated":"2017-12-19T08:24:15.533Z","comments":true,"path":"2017/12/19/jQuery插件Datatables的使用/","link":"","permalink":"http://Ison-Laihus.github.io/2017/12/19/jQuery插件Datatables的使用/","excerpt":"","text":"Datatables介绍Datatables是一款jquery表格插件，他是一个高度灵活的工具，可以将任何HTML表格添加高机的交互功能。特性： 分页，即时搜索和排序 几乎支持任何数据源：DOM，javascript，Ajax和服务器处理 支持不同的主题DataTables，JQuery UI，Bootstrap，Foundation 各式各样的扩展：Editor，TableTools，FixedColumns…… 丰富多样的option和强大的API 免费开源(MIT license) Datatables的使用Datatables的使用十分简单，只需要引入其提供给我们的css文件和js文件，我们就可以使用它了。这两个文件，你可以到官网上去下载，也可以直接使用它给我们提供的CDNcss1//cdn.datatables.net/1.10.15/css/jquery.dataTables.min.css js1//cdn.datatables.net/1.10.15/js/jquery.dataTables.min.js 当直接使用上述CDN时，一定需要开服务器，在服务器下运行html程序，否则不能正确定位到CDN如果不想开服务器，就想直接运行，请在css和js的CDN地址前加上一个http: 然后我们就可以尝试一下这个插件了！在html中写一个表格1234567891011121314151617181920212223242526&lt;table id=&quot;demo&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;column one&lt;/td&gt; &lt;td&gt;column two&lt;/td&gt; &lt;td&gt;column three&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;line one one&lt;/td&gt; &lt;td&gt;line one two&lt;/td&gt; &lt;td&gt;line one three&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;line two one&lt;/td&gt; &lt;td&gt;line two two&lt;/td&gt; &lt;td&gt;line two three&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;line three one&lt;/td&gt; &lt;td&gt;line three two&lt;/td&gt; &lt;td&gt;line three three&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 效果如下： 使用Datatables1$(&quot;#demo&quot;).DataTable(); 效果如下： 可以看到，Datatables这个插件自动帮我们加上了css样式，以及分页，搜索，排序等功能。 在使用Datatables的使用，一定要注意需要引入jquery，因为Datatables是基于jquery开发的。 使用Datatables加载数据在上述的例子中，我们是写好一个table，然后使用Datatables将他进行样式添加，功能添加的。但是如果每次都需要我们在HTML中手动添加数据，就会令人感觉十分繁琐，能不能有一种简单的方式来加载数据呢，实现数据与HTML分离，这样当数据进行变更时也方便修改。 答案是肯定的。Datatables能够自动加载数据，然后帮助我们生成dom元素填充到html中。使用这个功能时，html就只需要这么一行代码就OK了。1&lt;table id=&quot;demo&quot;&gt;&lt;/table&gt; 在javascript中使用数组存储数据源12345var dataSet = [ [&quot;line one one&quot;, &quot;line one two&quot;, &quot;line one three&quot;], [&quot;line two one&quot;, &quot;line two two&quot;, &quot;line two three&quot;], [&quot;line three one&quot;, &quot;line three two&quot;, &quot;line three three&quot;]]; 然后将其作为参数传入到Datatables的参数中12345678$(&quot;#demo&quot;).DataTable(&#123; data: dataSet, columns: [ // 定义每个列的标题 &#123;title: &quot;column one&quot;&#125;, &#123;title: &quot;column two&quot;&#125;, &#123;title: &quot;column three&quot;&#125; ]&#125;); 通过Ajax加载数据使用json格式将数据独立存储在文件中dataSet.json12345678910111213141516171819&#123; &quot;data&quot;: [ [ &quot;line one one&quot;, &quot;line one two&quot;, &quot;line one three&quot; ], [ &quot;line two one&quot;, &quot;line two two&quot;, &quot;line two three&quot; ], [ &quot;line three one&quot;, &quot;line three two&quot;, &quot;line three three&quot; ] ]&#125; 一定要注意，在使用json格式的数据，需要有一个名为data的key，这个key的value才是你要存放的数据数组 然后将其作为参数传入到Datatables的参数中12345678$(&quot;#demo&quot;).DataTable(&#123; ajax: &apos;dataSet.json&apos;, columns: [ // 定义每个列的标题 &#123;title: &quot;column one&quot;&#125;, &#123;title: &quot;column two&quot;&#125;, &#123;title: &quot;column three&quot;&#125; ]&#125;); 使用ajax的方式，一定得将html脚本运行在服务器上，否则不能成功加载 这个应该是应用得很广，在进行前后台交互的时候，我们可以直接使用这个功能，将后台传来的符合格式的数据直接通过Datatables加载到html页面上。 表格美化虽然面讲述了datatable的强大的功能，但是那界面未免令人不敢恭维。别担心，Datatables自知有这个缺点，索性它人品不错，和很多美工大师关系很好，我们能够直接以它的名义邀请他的朋友来帮忙。在这里，我们就直接邀请其非常有名的朋友，bootstrap来助我们一臂之力。 首先，我们得先引入bootstarp以及Datatables提供的和bootstrap一起工作的文件css12http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.csshttps://cdn.datatables.net/1.10.16/css/dataTables.bootstrap.min.css js1https://cdn.datatables.net/1.10.16/js/dataTables.bootstrap.min.js 然后，只需要改变html，给他加一个bootstrap提供的类名就行了1&lt;table id=&quot;demo&quot; class=&quot;table table-striped table-bordered&quot;&gt;&lt;/table&gt; 效果如下是不是好看了很多呢：） 至此，jQuery插件Datables的基本功能的使用已经介绍完了，Datatables还有很多其他的高级功能，后续博客，敬请期待！","categories":[],"tags":[{"name":"javascript plugins","slug":"javascript-plugins","permalink":"http://Ison-Laihus.github.io/tags/javascript-plugins/"}]},{"title":"XML介绍与实例","slug":"XML介绍与实例","date":"2017-12-18T12:16:24.000Z","updated":"2017-12-18T12:34:38.056Z","comments":true,"path":"2017/12/18/XML介绍与实例/","link":"","permalink":"http://Ison-Laihus.github.io/2017/12/18/XML介绍与实例/","excerpt":"","text":"简介XML是什么XML 是Extensible Markup Language的缩写，意思是可扩展标记语言。XML 是一个十分类似于HTML的语言。XML 是被设计来存储和传输数据的语言。XML 是一款自描述语言。 XML和HTML的差别XML和HTML是出于不同的目的而被设计出来的： XML被设计出来存储和传输数据——其专注于数据的内容 HTML被设计出来展示数据——其专注于数据的外观 XML标签是没有被预定义的，HTML标签是被预定义的 预定义就是提前设计好了，规定好了，你必须使用他设计好的标签，而不能使用别的没有预定义就是你可以随便自己定义标签，只要你觉得这个标签能描述出你所要描述的东西 XML仅仅是纯文本XML仅仅是携带数据的纯文本，有能力处理纯文本的软件都可以处理XML。 XML标签XML允许作者定义自己的标签和文档结构。 XML能干什么从HTML中分离数据当用HTML展示数据的时候，当数据改变时，你不一定非得修改HTML文件，你可以使用XML存储数据形成一个单独的文件，然后使用几行JavaScript代码从XML文件中读取数据填充到HTML中。当数据更新时，只需要修改XML文件即可，HTML文件的数据也会同步跟新。 HTML文件往往都很复杂，因为其中不仅仅只是包含数据，还包含一些动画，图片等需要复杂HTML标签才能展示的效果。在这些标签中寻找数据，往往十分困难。 简化数据共享XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。这让创建不同应用程序可以共享的数据变得更加容易。 简化数据传输因为任何系统都能够读取纯文本数据，因此通过XML可以在不兼容的系统之间轻松地交换数据。 实践关于XML的一些语法，我就不多加赘述了，如果大家感兴趣的话，可以去W3School上去学习。 下面，我们就使用代码来介绍一下如何使用XML进行数据的存储，应用于HTML程序。 首先，我们先使用XML存储我们想要显示的数据。例如，我想写一封邮件给我的同学，那么我就使用XML来存储关键的数据。1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;email&gt; &lt;from&gt;lyk&lt;/from&gt; &lt;to&gt;my friend&lt;/to&gt; &lt;title&gt;Thanks For Your Help&lt;/title&gt; &lt;content&gt;Yesterday, I forgot my pen in English test. You borrowed your pen to me. Thank your very much&lt;/content&gt; &lt;email&gt; 这里的所有标签都是我自己自己定义的 然后，我们就使用HTML来写一个网页来展示这些数据1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Email&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;title&quot;&gt;&lt;/div&gt; &lt;div class=&quot;subtitle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最后，我们使用JavaScript将XML中的数据填充到HTML页面中12","categories":[],"tags":[]},{"title":"github+hexo搭建个人博客","slug":"github-hexo搭建个人博客","date":"2017-12-08T16:29:07.000Z","updated":"2017-12-10T08:29:16.094Z","comments":true,"path":"2017/12/09/github-hexo搭建个人博客/","link":"","permalink":"http://Ison-Laihus.github.io/2017/12/09/github-hexo搭建个人博客/","excerpt":"","text":"步骤概览 注册一个github账号以及配置 在本地下载git，nodejs 下载hexo 在本地建立博客仓库 关联github page 选用主题 撰写博客 注册一个github账号以及配置我们的博客是由github+hexo搭建而成的，所以github必定是基础中的基础，前提中的前提。 什么是github？github是一个面向开元及私有软件项目的管理平台，因为只支持git作为唯一的版本库格式进行托管，故名github。 Step One首先，我们得去github去注册一个账号。 sign up 是注册， sign in 是登录 Step Two新建一个代码库，点击右上角的加号，点击New repository命名你要创建的代码库，这里需要注意，你代码库的名字一定得是yourname.github.io这里的yourname是你的账户名至于description，你可写可不写，然后点击最下方的create repository绿色按钮就OK了 Step Three设置代码库，开启gh-pages功能，这个功能是我们能够利用github搭建个人博客的重要功能。代码库创建成功之后，我们会进入如下界面：然后点击图片上部菜单末尾的settings属性，下滑到Github Pages设置这块由他的描述可知，github pages被设计为从Github库中托管您的个人、组织或项目页面。我们也获知其现在是无效的，需要我们往其中添加内容。我们可以点击下方的choose a theme按钮，然后选择你喜爱的风格：点击select theme按钮，它默认给你创建了一个issue，填充好了内容，然后你只需点击commit changes按钮即可 如果您完成了上述的工作，name恭喜你，你已经完成了第一部分的内容。然后您可以在浏览器的地址栏输入https://yourname.github.io查看您的项目页面。 在本地下载git，nodejs为甚我们需要下载git和nodejs呢？因为我们选用的hexo框架依赖于git和nodejs。 我们可以去git官网上去下载git。下载完成之后，双击安装即可。 强烈建议不要将其安装到C盘 然后一直next，知道finish 然后在桌面空白处点击右键，就会发现右键菜单中多出了Git GUI Here 和 Git Bash Here这两个选项 然后安装nodejs，官网网址点击.msi文件或是.zip文件均可，然后下载安装或解压。 要注意，需要配置环境变量在 控制面板 &gt; 系统和安全 &gt; 系统 &gt; 高级系统设置 &gt; 环境变量 &gt; 系统变量中的path &gt; 编辑 &gt; 新建 &gt; 将你安装node的文件路径复制然后一直点击确认即可 下载hexo什么是Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装hexo，打开命令行，执行如下命令 1npm install -g hexo 安装成功，可以执行hexo -v查看安装的版本 建立博客代码库新建一个文件夹，cmd运行进入到该目录下，使用hexo init命令初始化代码库然后使用如下命令1npm install --save hexo-deployer-git 安装所需的一些依赖包 运行博客 清除缓存文件 1hexo clean 生成静态文件 1hexo generate 或 hexo g 启动服务器 1hexo server 执行完上述命令，打开浏览器，输入http://localhost:4000，即可看到稍微满意的结果 关联github page配置git个人信息打开git bash，输入如下命令：12git config --global user.name &quot;xxx&quot; git config --global user.emal &quot;xxx@xxx.xxx&quot; 将其中的xxx替换成您自己的信息 然后使用如下命令生成秘钥：1ssh-keygen -t rsa -C &quot;your email&quot; 请将your email替换成您自己的邮箱 执行完毕，就会在C盘的用户目录下生成一个.ssh文件夹，其中会有id_rsa和id_rsa.pub这两个文件，分别是私钥和公钥 添加生成的秘钥到到ssh-agent12eval `ssh-agent -s` # 启动ssh-agent ssh-add # 添加秘钥 将公钥复制，进入github settings中的Deploy Keys选项，点击Add Deploy Key按钮将公钥复制到Key文本栏中，title栏可以任意填点击 Add Key即可 这是为了避免您每次想github推送您更新的博客时，都需要输入您的用户名和密码，配置公钥私钥能够让git自动帮您进行认证 配置Deployment在您博客代码库的根目录下有一个_config.yml文件，这是您网站的配置文件。您需要进行一些修改以匹配您的git page1234deploy: type: git repo: git@github.com:Ison-Laihus/Ison-Laihus.github.io.git branch: master 请进行相应的替换 在_config.yml文件中还有其他一些参数可以配置例如： 修改博客站点信息1234567# Sitetitle: Ison Blog subtitle: happy to have a blog description:author: Ison language:timezone: 将本地博客部署到github pages部署命令1hexo deploy 或 hexo d 但是需要注意，在部署之前，需要先进行清除缓存和生成静态文件的命令 然后再浏览器中输入URL: https://yourname.gihub.io，就会发现已经将本地博客部署到github上了 选用主题在github上，有许许多多github的主题，您可以在github上进行搜索 您可以选择您喜爱的主题，然后下载到本地博客代码仓库themes文件夹下 例如，我们选择hexo-theme-even这个主题，然后使用git bash从github上克隆下来12npm install hexo-renderer-scss --save # 首先安装依赖的包 git clone git@github.com:ahonn/hexo-theme-even.git themes/even 后面的themes/even请根据您的自身情况进行修改 然后修改_config.yml文件中的theme字段，因为我们将下载的主题命名为even，所以我们将这个字段设置为even 然后清除缓存，生成静态文件，部署在浏览器输入URL: https://yourname.gihub.io，发现博客主题已经被更改，但是却很糟糕 这里不知道是不是作者写错了还是怎么，不过我们可以做一些修改： 进入主题even的文件夹中，进入layout/_partial文件夹下，打开head.swig文件，将如下两行代码做些修改123&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;&#123;&#123; url_for(theme.favicon) &#125;&#125;?v=&#123;&#123; theme.version &#125;&#125;&quot; /&gt; ··· &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;&#123; url_for(&apos;css/style.css&apos;) &#125;&#125;?v=&#123;&#123; theme.version &#125;&#125;&quot; /&gt; 修改成123&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;&#123;&#123; url_for(theme.favicon) &#125;&#125;&quot; /&gt; ··· &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;&#123; url_for(&apos;css/style.css&apos;) &#125;&#125;&quot; /&gt; 然后执行必备的三步，即可看到炫酷的效果 是不是很酷炫呢:) 撰写博客终于到了我们最后一个模块了——撰写博客 hexo有一个新建博客文章的命令1hexo new &lt;title&gt; 该命令会自动在source/_post文件夹下生成一个markdown文件，然后我们可以使用Markown编辑器打开这个文件进行编辑，撰写我们的博客。 这似乎很简单，但是这并不是我所要说的重点。 我所说的重点是，如何在我们的博客代码仓库存储我们的数据文件，例如，如果有一张图片，我们该怎么保存在我们的图片呢？ 不要着急，hexo给我们提供了这个功能。 我们只需要在根目录下的_config.yml中修改post_asset_folder的字段设置为true1post_asset_folder: true 然后当我们使用新建博客文章的命令的同时，会在source/_post目录下生成一个与你博客文章同名的文件夹，你可以将你的数据文件放入这个文件夹中，然后使用如下命令进行引用：1&#123;% asset_img example.jpg This is an example image %&#125; asset_img是不能更改的，example.jpg根据您的图片名称进行修改，This is an example是描述语句，可以任意更改。 结语至此，使用github+hexo搭建个人博客已经完成，如果有误，希望指正。更多内容，请参考hexo官方文档","categories":[],"tags":[{"name":"部署","slug":"部署","permalink":"http://Ison-Laihus.github.io/tags/部署/"}]}]