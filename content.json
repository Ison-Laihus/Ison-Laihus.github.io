[{"title":"JavaScript 继承","slug":"JavaScript-继承","date":"2018-03-19T14:08:10.000Z","updated":"2018-03-19T14:37:31.928Z","comments":true,"path":"2018/03/19/JavaScript-继承/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/19/JavaScript-继承/","excerpt":"","text":"许多OO语言都支持两种继承方式： 接口继承：只继承方法签名 实现继承：继承实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现继承主要依靠原型链来实现的。 function SuperType() { this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; this.property = true; } function SubType() { this.subProperty = true; } // 继承 SubType.prototype = new SuperType(); var instance = new SubType(); 两个问题： 包含引用类型值的原型，会被所有实例共享 在创建子类型的实例时，不能向超类型的构造函数中传递参数 借用构造函数原理：函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在新创建的对象上执行构造函数。 function SuperType() { this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } function SubType() { SuperType.call(this); } var instance = new SubType(); instance.colors.push(&quot;black&quot;); console.log(instance.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;] 传递参数相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。 问题方法都在构造函数中定义，因此函数复用就无从谈起了。在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都智能使用构造函数模式。 组合继承有时也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承。 function SuperType(name) { this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } SuperType.prototype.sayName = function() { console.log(this.name); } function SubType(name, age) { SuperType.call(this, name); // 第二次调用 SuperType() this.age = age; } SubType.prototype = new SuperType(); // 第一次调用 SuperType() SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() { console.log(this.age); } 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中做常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。 原型式继承借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。 function object(o) { function F(){} F.prototype = o; return new F(); } var person = { colors: [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;] }; // obj继承person对象 var obj = object(person); Object.create(fatherObj[, propertiesObj])ECMAScript5通过新增Object.create()方法规范化了原型继承。fatherObj: 要继承的父类对象propertiesObj: 和Object.defineProperties()中第二个参数一样，会覆盖原有同名属性。可选 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再想真的是它做了所有工作一样返回对象。 function createAnother(original) { var clone = object(original); clone.sayHi = function() { console.log(&quot;HI&quot;); } return clone; } 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。 前面的object()函数不是必须的，任何能够返回新对象的函数都适用于此模式。 使用寄生式继承来为对象添加函数，会由于不能做到函数服用而降低效率。这一点与构造函数模式类似 寄生组合式继承由于组合继承存在一个很大的缺陷： 其会调用两次超类型构造函数，一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 因为子类型最终会包含超类型对象的全部实例属性，所以我们不得不在调用子类型构造函数时重写这些属性。 解决办法：寄生组合式继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 背后的思路：不必为了指定子类型的原型而调用超类型的构造函数，我们需要的无非就是超类型原型的一个副本而已。 本质：使用寄生式继承来继承超类型的原型，然后在将结果指定给子类型的原型。 function inheritPrototype(subType, superType) { var prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象 } 这个例子能够保持原型链不变，还避免了在SubType.prototype上面创建不必要的、多余的属性。 这被普遍认为是引用类型最理想的继承范式。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://Ison-Laihus.github.io/tags/JavaScript/"}]},{"title":"'JavaScript严格模式'","slug":"JavaScript严格模式","date":"2018-03-18T07:54:43.000Z","updated":"2018-03-18T08:43:10.244Z","comments":true,"path":"2018/03/18/JavaScript严格模式/","link":"","permalink":"http://Ison-Laihus.github.io/2018/03/18/JavaScript严格模式/","excerpt":"","text":"ECMAScript5最早引入了“严格模式”（strict mode）的概念。通过严格模式，可以在函数内部选择进行较为严格的全局或局部的错误条件检测。 使用严格模式的好处：可以提早知道代码中存在的错误，即使捕获一些可能导致编程错误的ECMAScript行为。 选择使用选择进入严格模式，需使用严格模式的编译指示： &quot;use strict&quot;; 其其实是一个为负值的字符串字面量，支持严格模式的引擎会启动严格模式，不支持的就会忽略。 变量严格模式下，什么时候创建变量以及怎么创建变量都是有限制的。 不允许意外创建全局变量message = &quot;Hello&quot;; 这行代码在严格模式下是错误的。在严格模式下，如果给一个没有声明的变量复制，那代码在执行时就会抛出ReferenceError 不能对变量调用delete操作符var clolor = &quot;red&quot;; delete color; 在严格模式下上述代码会出错。虽在非严格模式下允许这样做，但是会静默失败（返回false） 严格模式下对变量有限制不能使用implements, interface, let, package, private, protected, public, static, yield作为变量名，这些都是保留字，将来的ECMAScript版本中可能会用到它们。 对象在严格模式下操作对象比在非严格模式下更容易导致错误。一般来说，在非严格模式下回静默失败的情形，在严格模式下回抛出错误。 在下列情形下操作对象的属性会导致错误： 为只读属性赋值——抛出TypeError 对不可配置的属性使用delete操作符——抛出TypeError 对不可扩展的对象添加属性——抛出TypeError 使用对象字面量时，属性名必须唯一var person = { name: &quot;xiaoming&quot;, name: &quot;honghong&quot; } 严格模式下报错，非严格模式下取第二个。 函数严格模式下的函数命名必须唯一。不能出现两个命名一样的函数，JavaScript中没有像C++中的函数重载。 严格模式下，arguments对象的行为也有所不同 非严格模式：arguments对象和命名参数双向绑定，改动任何一个，另一个的值也会随之改变 严格模式：arguments对象和命名参数无双向绑定 淘汰了arguments.callee 和 arguments.caller在非严格模式下，这两个属性一个引用函数本身，一个引用调用函数。在严格模式下，访问哪个属性都会抛出TypeError。 函数名不能使用保留字只能在脚本的顶级和在函数内部声明函数if (true) { function doSomething() { // ... } } 严格模式下，会导致语法错误。 eval()严格模式下，eval()在包含上下文中不再创建变量和函数。 function doSomething() { eval(&quot;var x = 10&quot;); alert(x); } 上述代码在严格模式下会抛出ReferenceError，因为x未被定义。 可以在eval()中声明变量和函数，但这些变量或函数只能被求值的特殊作用域中有效，随后就会被销毁。 &quot;use strict&quot;; var result = eval(&quot;var x=10, y = 11; x+y&quot;); console.log(result); // 21 上述代码是有效的。 eval和arguments严格模式已经明确禁止使用eval和arguments作为标识符，也不允许读写它们的值。而在非严格模式下是可以重写eval，也可以给arguments赋值。 抑制this在非严格模式下使用函数的apply()和call()方法时，null或undefined值会被转换为全局对象。 而在严格模式下，函数的this值始终是指定的值，无论指定的是什么值。 var color = &quot;red&quot;; function displayColor() { console.log(this.color); } displayColor.call(null); 非严格模式下输出red，this是全局对象严格模式下报错，this是null，对null操作报错 其他 抛弃了with语句——使用会导致语法错误 去掉了JavaScript中的八进制字面量","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://Ison-Laihus.github.io/tags/javascript/"}]},{"title":"人工智能笔记之人工智能概念","slug":"人工智能笔记之人工智能概念","date":"2018-01-02T12:04:33.000Z","updated":"2018-03-18T08:00:18.114Z","comments":true,"path":"2018/01/02/人工智能笔记之人工智能概念/","link":"","permalink":"http://Ison-Laihus.github.io/2018/01/02/人工智能笔记之人工智能概念/","excerpt":"","text":"人工智能分类| 像人一样思考 | 合理地（理性）思考 || 像人一样行动 | 合理地（理性）行动 | 像人一样行动：图灵测试自然语言处理，知识表示，自动推理，机器学习，计算机视觉，机器人学 像人一样思考：认知建模神经生理学实验，心理学实验，认知模型 理性地思考：思维法则逻辑学 理性地行动：理性智能体 理性行动：做正确的事 正确的事：在当前已有知识和前提条件下，能获得最佳期望结果的决定或行动 智能体是能感知和行动的实体 理性智能体智能体：指任何能通过传感器感知环境和通过执行器作用于环境的实体 理性智能体：对于每种可能的感知系列，理性智能体应该选择一个这样的动作来执行，此动作能在它所具有执行和感知序列提供的证据条件下，使得它的性能度量期望最大化。 理性有别于无所不知 智能体的设计在设计智能体时须首先明确的四大要素，简称PEAS 性能度量（Performance measure） 环境（Environment） 执行器（Actuators） 传感器（Sensors）","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://Ison-Laihus.github.io/tags/AI/"}]},{"title":"jQuery插件Datatables的使用","slug":"jQuery插件Datatables的使用","date":"2017-12-19T06:51:58.000Z","updated":"2017-12-19T08:24:15.533Z","comments":true,"path":"2017/12/19/jQuery插件Datatables的使用/","link":"","permalink":"http://Ison-Laihus.github.io/2017/12/19/jQuery插件Datatables的使用/","excerpt":"","text":"Datatables介绍Datatables是一款jquery表格插件，他是一个高度灵活的工具，可以将任何HTML表格添加高机的交互功能。特性： 分页，即时搜索和排序 几乎支持任何数据源：DOM，javascript，Ajax和服务器处理 支持不同的主题DataTables，JQuery UI，Bootstrap，Foundation 各式各样的扩展：Editor，TableTools，FixedColumns…… 丰富多样的option和强大的API 免费开源(MIT license) Datatables的使用Datatables的使用十分简单，只需要引入其提供给我们的css文件和js文件，我们就可以使用它了。这两个文件，你可以到官网上去下载，也可以直接使用它给我们提供的CDNcss1//cdn.datatables.net/1.10.15/css/jquery.dataTables.min.css js1//cdn.datatables.net/1.10.15/js/jquery.dataTables.min.js 当直接使用上述CDN时，一定需要开服务器，在服务器下运行html程序，否则不能正确定位到CDN如果不想开服务器，就想直接运行，请在css和js的CDN地址前加上一个http: 然后我们就可以尝试一下这个插件了！在html中写一个表格1234567891011121314151617181920212223242526&lt;table id=&quot;demo&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;column one&lt;/td&gt; &lt;td&gt;column two&lt;/td&gt; &lt;td&gt;column three&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;line one one&lt;/td&gt; &lt;td&gt;line one two&lt;/td&gt; &lt;td&gt;line one three&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;line two one&lt;/td&gt; &lt;td&gt;line two two&lt;/td&gt; &lt;td&gt;line two three&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;line three one&lt;/td&gt; &lt;td&gt;line three two&lt;/td&gt; &lt;td&gt;line three three&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 效果如下： 使用Datatables1$(&quot;#demo&quot;).DataTable(); 效果如下： 可以看到，Datatables这个插件自动帮我们加上了css样式，以及分页，搜索，排序等功能。 在使用Datatables的使用，一定要注意需要引入jquery，因为Datatables是基于jquery开发的。 使用Datatables加载数据在上述的例子中，我们是写好一个table，然后使用Datatables将他进行样式添加，功能添加的。但是如果每次都需要我们在HTML中手动添加数据，就会令人感觉十分繁琐，能不能有一种简单的方式来加载数据呢，实现数据与HTML分离，这样当数据进行变更时也方便修改。 答案是肯定的。Datatables能够自动加载数据，然后帮助我们生成dom元素填充到html中。使用这个功能时，html就只需要这么一行代码就OK了。1&lt;table id=&quot;demo&quot;&gt;&lt;/table&gt; 在javascript中使用数组存储数据源12345var dataSet = [ [&quot;line one one&quot;, &quot;line one two&quot;, &quot;line one three&quot;], [&quot;line two one&quot;, &quot;line two two&quot;, &quot;line two three&quot;], [&quot;line three one&quot;, &quot;line three two&quot;, &quot;line three three&quot;]]; 然后将其作为参数传入到Datatables的参数中12345678$(&quot;#demo&quot;).DataTable(&#123; data: dataSet, columns: [ // 定义每个列的标题 &#123;title: &quot;column one&quot;&#125;, &#123;title: &quot;column two&quot;&#125;, &#123;title: &quot;column three&quot;&#125; ]&#125;); 通过Ajax加载数据使用json格式将数据独立存储在文件中dataSet.json12345678910111213141516171819&#123; &quot;data&quot;: [ [ &quot;line one one&quot;, &quot;line one two&quot;, &quot;line one three&quot; ], [ &quot;line two one&quot;, &quot;line two two&quot;, &quot;line two three&quot; ], [ &quot;line three one&quot;, &quot;line three two&quot;, &quot;line three three&quot; ] ]&#125; 一定要注意，在使用json格式的数据，需要有一个名为data的key，这个key的value才是你要存放的数据数组 然后将其作为参数传入到Datatables的参数中12345678$(&quot;#demo&quot;).DataTable(&#123; ajax: &apos;dataSet.json&apos;, columns: [ // 定义每个列的标题 &#123;title: &quot;column one&quot;&#125;, &#123;title: &quot;column two&quot;&#125;, &#123;title: &quot;column three&quot;&#125; ]&#125;); 使用ajax的方式，一定得将html脚本运行在服务器上，否则不能成功加载 这个应该是应用得很广，在进行前后台交互的时候，我们可以直接使用这个功能，将后台传来的符合格式的数据直接通过Datatables加载到html页面上。 表格美化虽然面讲述了datatable的强大的功能，但是那界面未免令人不敢恭维。别担心，Datatables自知有这个缺点，索性它人品不错，和很多美工大师关系很好，我们能够直接以它的名义邀请他的朋友来帮忙。在这里，我们就直接邀请其非常有名的朋友，bootstrap来助我们一臂之力。 首先，我们得先引入bootstarp以及Datatables提供的和bootstrap一起工作的文件css12http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.csshttps://cdn.datatables.net/1.10.16/css/dataTables.bootstrap.min.css js1https://cdn.datatables.net/1.10.16/js/dataTables.bootstrap.min.js 然后，只需要改变html，给他加一个bootstrap提供的类名就行了1&lt;table id=&quot;demo&quot; class=&quot;table table-striped table-bordered&quot;&gt;&lt;/table&gt; 效果如下是不是好看了很多呢：） 至此，jQuery插件Datables的基本功能的使用已经介绍完了，Datatables还有很多其他的高级功能，后续博客，敬请期待！","categories":[],"tags":[{"name":"javascript plugins","slug":"javascript-plugins","permalink":"http://Ison-Laihus.github.io/tags/javascript-plugins/"}]},{"title":"XML介绍与实例","slug":"XML介绍与实例","date":"2017-12-18T12:16:24.000Z","updated":"2017-12-18T12:34:38.056Z","comments":true,"path":"2017/12/18/XML介绍与实例/","link":"","permalink":"http://Ison-Laihus.github.io/2017/12/18/XML介绍与实例/","excerpt":"","text":"简介XML是什么XML 是Extensible Markup Language的缩写，意思是可扩展标记语言。XML 是一个十分类似于HTML的语言。XML 是被设计来存储和传输数据的语言。XML 是一款自描述语言。 XML和HTML的差别XML和HTML是出于不同的目的而被设计出来的： XML被设计出来存储和传输数据——其专注于数据的内容 HTML被设计出来展示数据——其专注于数据的外观 XML标签是没有被预定义的，HTML标签是被预定义的 预定义就是提前设计好了，规定好了，你必须使用他设计好的标签，而不能使用别的没有预定义就是你可以随便自己定义标签，只要你觉得这个标签能描述出你所要描述的东西 XML仅仅是纯文本XML仅仅是携带数据的纯文本，有能力处理纯文本的软件都可以处理XML。 XML标签XML允许作者定义自己的标签和文档结构。 XML能干什么从HTML中分离数据当用HTML展示数据的时候，当数据改变时，你不一定非得修改HTML文件，你可以使用XML存储数据形成一个单独的文件，然后使用几行JavaScript代码从XML文件中读取数据填充到HTML中。当数据更新时，只需要修改XML文件即可，HTML文件的数据也会同步跟新。 HTML文件往往都很复杂，因为其中不仅仅只是包含数据，还包含一些动画，图片等需要复杂HTML标签才能展示的效果。在这些标签中寻找数据，往往十分困难。 简化数据共享XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。这让创建不同应用程序可以共享的数据变得更加容易。 简化数据传输因为任何系统都能够读取纯文本数据，因此通过XML可以在不兼容的系统之间轻松地交换数据。 实践关于XML的一些语法，我就不多加赘述了，如果大家感兴趣的话，可以去W3School上去学习。 下面，我们就使用代码来介绍一下如何使用XML进行数据的存储，应用于HTML程序。 首先，我们先使用XML存储我们想要显示的数据。例如，我想写一封邮件给我的同学，那么我就使用XML来存储关键的数据。1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;email&gt; &lt;from&gt;lyk&lt;/from&gt; &lt;to&gt;my friend&lt;/to&gt; &lt;title&gt;Thanks For Your Help&lt;/title&gt; &lt;content&gt;Yesterday, I forgot my pen in English test. You borrowed your pen to me. Thank your very much&lt;/content&gt; &lt;email&gt; 这里的所有标签都是我自己自己定义的 然后，我们就使用HTML来写一个网页来展示这些数据1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Email&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;title&quot;&gt;&lt;/div&gt; &lt;div class=&quot;subtitle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最后，我们使用JavaScript将XML中的数据填充到HTML页面中12","categories":[],"tags":[]},{"title":"github+hexo搭建个人博客","slug":"github-hexo搭建个人博客","date":"2017-12-08T16:29:07.000Z","updated":"2017-12-10T08:29:16.094Z","comments":true,"path":"2017/12/09/github-hexo搭建个人博客/","link":"","permalink":"http://Ison-Laihus.github.io/2017/12/09/github-hexo搭建个人博客/","excerpt":"","text":"步骤概览 注册一个github账号以及配置 在本地下载git，nodejs 下载hexo 在本地建立博客仓库 关联github page 选用主题 撰写博客 注册一个github账号以及配置我们的博客是由github+hexo搭建而成的，所以github必定是基础中的基础，前提中的前提。 什么是github？github是一个面向开元及私有软件项目的管理平台，因为只支持git作为唯一的版本库格式进行托管，故名github。 Step One首先，我们得去github去注册一个账号。 sign up 是注册， sign in 是登录 Step Two新建一个代码库，点击右上角的加号，点击New repository命名你要创建的代码库，这里需要注意，你代码库的名字一定得是yourname.github.io这里的yourname是你的账户名至于description，你可写可不写，然后点击最下方的create repository绿色按钮就OK了 Step Three设置代码库，开启gh-pages功能，这个功能是我们能够利用github搭建个人博客的重要功能。代码库创建成功之后，我们会进入如下界面：然后点击图片上部菜单末尾的settings属性，下滑到Github Pages设置这块由他的描述可知，github pages被设计为从Github库中托管您的个人、组织或项目页面。我们也获知其现在是无效的，需要我们往其中添加内容。我们可以点击下方的choose a theme按钮，然后选择你喜爱的风格：点击select theme按钮，它默认给你创建了一个issue，填充好了内容，然后你只需点击commit changes按钮即可 如果您完成了上述的工作，name恭喜你，你已经完成了第一部分的内容。然后您可以在浏览器的地址栏输入https://yourname.github.io查看您的项目页面。 在本地下载git，nodejs为甚我们需要下载git和nodejs呢？因为我们选用的hexo框架依赖于git和nodejs。 我们可以去git官网上去下载git。下载完成之后，双击安装即可。 强烈建议不要将其安装到C盘 然后一直next，知道finish 然后在桌面空白处点击右键，就会发现右键菜单中多出了Git GUI Here 和 Git Bash Here这两个选项 然后安装nodejs，官网网址点击.msi文件或是.zip文件均可，然后下载安装或解压。 要注意，需要配置环境变量在 控制面板 &gt; 系统和安全 &gt; 系统 &gt; 高级系统设置 &gt; 环境变量 &gt; 系统变量中的path &gt; 编辑 &gt; 新建 &gt; 将你安装node的文件路径复制然后一直点击确认即可 下载hexo什么是Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装hexo，打开命令行，执行如下命令 1npm install -g hexo 安装成功，可以执行hexo -v查看安装的版本 建立博客代码库新建一个文件夹，cmd运行进入到该目录下，使用hexo init命令初始化代码库然后使用如下命令1npm install --save hexo-deployer-git 安装所需的一些依赖包 运行博客 清除缓存文件 1hexo clean 生成静态文件 1hexo generate 或 hexo g 启动服务器 1hexo server 执行完上述命令，打开浏览器，输入http://localhost:4000，即可看到稍微满意的结果 关联github page配置git个人信息打开git bash，输入如下命令：12git config --global user.name &quot;xxx&quot; git config --global user.emal &quot;xxx@xxx.xxx&quot; 将其中的xxx替换成您自己的信息 然后使用如下命令生成秘钥：1ssh-keygen -t rsa -C &quot;your email&quot; 请将your email替换成您自己的邮箱 执行完毕，就会在C盘的用户目录下生成一个.ssh文件夹，其中会有id_rsa和id_rsa.pub这两个文件，分别是私钥和公钥 添加生成的秘钥到到ssh-agent12eval `ssh-agent -s` # 启动ssh-agent ssh-add # 添加秘钥 将公钥复制，进入github settings中的Deploy Keys选项，点击Add Deploy Key按钮将公钥复制到Key文本栏中，title栏可以任意填点击 Add Key即可 这是为了避免您每次想github推送您更新的博客时，都需要输入您的用户名和密码，配置公钥私钥能够让git自动帮您进行认证 配置Deployment在您博客代码库的根目录下有一个_config.yml文件，这是您网站的配置文件。您需要进行一些修改以匹配您的git page1234deploy: type: git repo: git@github.com:Ison-Laihus/Ison-Laihus.github.io.git branch: master 请进行相应的替换 在_config.yml文件中还有其他一些参数可以配置例如： 修改博客站点信息1234567# Sitetitle: Ison Blog subtitle: happy to have a blog description:author: Ison language:timezone: 将本地博客部署到github pages部署命令1hexo deploy 或 hexo d 但是需要注意，在部署之前，需要先进行清除缓存和生成静态文件的命令 然后再浏览器中输入URL: https://yourname.gihub.io，就会发现已经将本地博客部署到github上了 选用主题在github上，有许许多多github的主题，您可以在github上进行搜索 您可以选择您喜爱的主题，然后下载到本地博客代码仓库themes文件夹下 例如，我们选择hexo-theme-even这个主题，然后使用git bash从github上克隆下来12npm install hexo-renderer-scss --save # 首先安装依赖的包 git clone git@github.com:ahonn/hexo-theme-even.git themes/even 后面的themes/even请根据您的自身情况进行修改 然后修改_config.yml文件中的theme字段，因为我们将下载的主题命名为even，所以我们将这个字段设置为even 然后清除缓存，生成静态文件，部署在浏览器输入URL: https://yourname.gihub.io，发现博客主题已经被更改，但是却很糟糕 这里不知道是不是作者写错了还是怎么，不过我们可以做一些修改： 进入主题even的文件夹中，进入layout/_partial文件夹下，打开head.swig文件，将如下两行代码做些修改123&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;&#123;&#123; url_for(theme.favicon) &#125;&#125;?v=&#123;&#123; theme.version &#125;&#125;&quot; /&gt; ··· &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;&#123; url_for(&apos;css/style.css&apos;) &#125;&#125;?v=&#123;&#123; theme.version &#125;&#125;&quot; /&gt; 修改成123&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;&#123;&#123; url_for(theme.favicon) &#125;&#125;&quot; /&gt; ··· &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;&#123; url_for(&apos;css/style.css&apos;) &#125;&#125;&quot; /&gt; 然后执行必备的三步，即可看到炫酷的效果 是不是很酷炫呢:) 撰写博客终于到了我们最后一个模块了——撰写博客 hexo有一个新建博客文章的命令1hexo new &lt;title&gt; 该命令会自动在source/_post文件夹下生成一个markdown文件，然后我们可以使用Markown编辑器打开这个文件进行编辑，撰写我们的博客。 这似乎很简单，但是这并不是我所要说的重点。 我所说的重点是，如何在我们的博客代码仓库存储我们的数据文件，例如，如果有一张图片，我们该怎么保存在我们的图片呢？ 不要着急，hexo给我们提供了这个功能。 我们只需要在根目录下的_config.yml中修改post_asset_folder的字段设置为true1post_asset_folder: true 然后当我们使用新建博客文章的命令的同时，会在source/_post目录下生成一个与你博客文章同名的文件夹，你可以将你的数据文件放入这个文件夹中，然后使用如下命令进行引用：1&#123;% asset_img example.jpg This is an example image %&#125; asset_img是不能更改的，example.jpg根据您的图片名称进行修改，This is an example是描述语句，可以任意更改。 结语至此，使用github+hexo搭建个人博客已经完成，如果有误，希望指正。更多内容，请参考hexo官方文档","categories":[],"tags":[{"name":"部署","slug":"部署","permalink":"http://Ison-Laihus.github.io/tags/部署/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-07T12:53:43.641Z","updated":"2017-12-07T12:53:43.641Z","comments":true,"path":"2017/12/07/hello-world/","link":"","permalink":"http://Ison-Laihus.github.io/2017/12/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]